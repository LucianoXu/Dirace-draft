


\newcommand{\var}{\mathsf{var}}
\newcommand{\reg}{\mathsf{Reg}}
\newcommand{\DType}{\mathcal{D}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\tD}{\tilde{D}}
\newcommand{\te}{\tilde{e}}
\newcommand{\tT}{\tilde{T}}
\newcommand{\tADD}{\widetilde{ADD}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\<}{\langle}
\newcommand{\simp}{\mathsf{Simp}}
\newcommand{\List}{\mathsf{list}}
\renewcommand{\>}{\rangle}


\section{Labelled Dirac Notation}

Labelled Dirac notation uses register names to indicate the quantum system of vectors and operators. This allows us to talk aboud the states and operations locally, without referring to the whole system. For instance, assume $Q$ and $R$ are two registers, we have
\[
    M_Q \cdot \ket{\Phi}_{(Q, R)} = ((M \otimes I) \ket{\Phi})_{(Q, R)}.
\]
In the left hand side, the state of two subsystems is $\ket{\Phi}$, and we apply quantum operation $M$ on the system $Q$.


In this section, we introduce the language and typing of registers and labelled Dirac notations, and demonstrate how to transform the equivalence problem into the Dirac notations studied above.

We assume the set of register symbols is $\cR$. The syntax of quantum registers is defined as follows.
\begin{definition}[quantum registers]
  \begin{align*}
    R ::= r\in\cR \mid (R, R)
  \end{align*}
\end{definition}

Registers can be composed by pairs of $(R, R)$, and this structure corresponds to the structure of tensor product spaces in Dirac notations.

To reason about the registers, we define their variable set as the enumeration of all register symbols involved.

\begin{definition}[register variable set]
The variable set of a register is defined inductively by:
\begin{itemize}
    \item $R\equiv r$: $\var(R) = \{r\}$;
    \item $R\equiv (R_1,R_2)$: $\var(R) = \var(R_1) \cup\var(R_2)$.
\end{itemize}
\end{definition}

\textbf{Remark: } Set operations: $\cup$ for union; $\cap$ for intersection; $\setminus$ for difference. So,
% \begin{itemize}
$ S_1 \cap S_2 \equiv S_1 \cup S_2 \setminus (S_1 \setminus S_2) \setminus (S_2 \setminus S_1) $.
% \end{itemize}

\begin{definition}[labelled Dirac notation]
  The \textbf{labelled Dirac notation} includes all Dirac notation symbols and the generators defined below.
  Here, $s\subseteq \cR$ is a register variable set.
  \begin{align*}
    T & ::= \DType(s,s) \mid \mathsf{Reg}(\sigma) \\
    e & ::= R \mid |i\>_r \mid {}_r\<i| \mid e_R \mid e_{R;R} \mid
    e \otimes e \otimes \cdots \otimes e \mid e \cdot e \\
  \end{align*}
\end{definition}

$\DType(s_1, s_2)$ is the unified type for all labelled Dirac notations, where $s_1$ indicates the codomain systems and $s_2$ indicates the domain systems. For instance, labelled ket has type $\DType(s_1, \emptyset)$, and labelled bra has type $\DType(\emptyset, s_2)$.
$\reg(\sigma)$ are types for registers $R$, and the index $\sigma$ indicates the type of Hilbert space represented by the register.
Terms also include the labelled notation $e_R$ for bra, ket and $e_{R;R}$ for operators. We introduce new dot and tensor product symbols for labelled Dirac notations. In labelled Dirac notation, the structure of tensor product does not matter. Therefore $\otimes$ is an AC symbol.
Following the unified type $\DType(s,s)$, all kinds of multiplications are represented by the same dot product $e \cdot e$.
Finally, $\ket{i}_r$ and ${}_r\bra{i}$ are labelled basis for the normal form of labelled Dirac notations, where $r$ are registers symbols in $\mathcal{R}$. 

\subsubsection*{Typing rules}

\[
    \frac{E[\Gamma] \vdash  \sigma : \Index}{E[\Gamma] \vdash \reg(\sigma) : \Type}
    \qquad
    \frac{E[\Gamma] \vdash r : \reg(\sigma_r) \text{ for all $r$ in $s_1$ and $s_2$} }{E[\Gamma] \vdash \DType(s_1, s_2) : \textsf{Type}} 
\]

\[
    \frac{E[\Gamma] \vdash R : \reg(\sigma)\qquad E[\Gamma] \vdash K : \KType(\sigma)}{E[\Gamma] \vdash K_R : \DType(\var R, \emptyset)}
    \qquad
    \frac{E[\Gamma] \vdash D : \DType(s_1,s_2)}{E[\Gamma] \vdash D^\dagger : \DType(s_2,s_1)}
\]

The typing rule for tensor product is
\[
    \frac{
        E[\Gamma] \vdash D_i : \DType(s_i,s_i') \qquad
        \bigcap_i s_i = \emptyset \qquad
        \bigcap_i s_i' = \emptyset
    }
    {E[\Gamma] \vdash D_1 \otimes \cdots \otimes D_i : \DType(\bigcup_i s_i, \bigcup_i s_i')}.
\]

The typing rule for dot product is
\[
    \qquad
    \frac{
        \begin{aligned}
            E[\Gamma] \vdash D_1 : \DType(s_1,s_1') \\
            E[\Gamma] \vdash D_2 : \DType(s_2,s_2')
        \end{aligned}
        \qquad 
        \begin{aligned}
            s_1 \cap s_2 \backslash s_1' = \emptyset \\
            s_2' \cap s_1' \backslash s_2 = \emptyset
        \end{aligned}
    }
    {E[\Gamma] \vdash D_1\cdot D_2 : \DType(s_1 \cup (s_2\backslash s_1'), s_2' \cup (s_1'\backslash s_2))}.
\]

\subsection{Normalization}
The main idea of normalizing labelled Dirac notations is \textit{label elimination}. It expands $e_R$ and $e_{R;R}$ by tensor products of labelled basis, which are formalized as rules below.

\begin{align*}
    & K_R \ \reduce\ \sum_{i_{r_1}\in\bU(\sigma_{r_1})}\cdots \sum_{i_{r_n}\in\bU(\sigma_{r_n})} (\<i_R|\cdot K). (|i_{r_1}\>_{r_i}\otimes\cdots\otimes|i_{r_n}\>_{r_n}) \\
    %
    & B_R \ \reduce\ \sum_{i_{r_1}\in\bU(\sigma_{r_1})}\cdots \sum_{i_{r_n}\in\bU(\sigma_{r_n})} (B\cdot |i_R\>). ({}_{r_1}\<i_{r_1}|\otimes\cdots\otimes{}_{r_n}\<i_{r_n}|) \\
    %
    & O_{R,R'} \ \reduce\ \sum_{i_{r_1}\in\bU(\sigma_{r_1})}\cdots \sum_{i_{r_n}\in\bU(\sigma_{r_n})}
    \sum_{i_{r'_1}\in\bU(\sigma_{r'_1})}\cdots \sum_{i_{r'_{n'}}\in\bU(\sigma_{r'_{n'}})} \\
    & \qquad (\<i_R|\cdot O\cdot |i_{R'}\>).(|i_{r_1}\>_{r_i}\otimes\cdots\otimes|i_{r_n}\>_{r_n} \otimes {}_{r'_1}\<i_{r'_1}|\otimes\cdots\otimes{}_{r'_{n'}}\<i_{r'_{n'}}|)
\end{align*}

\begin{align*}
    & \textrm{(R-SUM-PUSHD0)}
    && X_1 \otimes \cdots (\sum_{i \in M} D) \cdots \otimes X_2\ \reduce\ \sum_{i \in M} (X_1 \otimes \cdots D \cdots \otimes X_n) \\
    %
    & \textrm{(R-SUM-PUSHD1)}
    && (\sum_{i \in M} D_1) \cdot D_2 \ \reduce\ \sum_{i \in M} (D_1 \cdot D_2) \\
\end{align*}

\begin{align*}
    %
    & \textrm{(R-L-SORT0)}
    && A : \DType(s_1, s_2), B : \DType(s_1', s_2'), s_2 \cap s_1'=\emptyset \Rightarrow A \cdot B \ \reduce\ A \otimes B \\
    %
    & \textrm{(R-L-SORT1)}
    && {}_r\bra{i}\cdot\ket{j}_r \ \reduce\ \delta_{i, j} \\
    %
    & \textrm{(R-L-SORT2)}
    && {}_r\bra{i}\cdot(Y_1 \otimes \cdots \otimes \ket{j}_r \otimes \cdots \otimes Y_m) \ \reduce\ \delta_{i, j}.(Y_1  \otimes \cdots \otimes Y_m) \\
    %
\end{align*}

\subsubsection*{Eliminating the registers}

\begin{enumerate}
  \item For any register $R$ s.t. $E[\Gamma]\vdash R : \reg \sigma$, suppose $\var R = \{r_1,r_2,\cdots,r_n\}$, 
  we introduce variables $i_{r_k} : \Basis(\sigma_{r_k})$ with $r_k : \reg \sigma_{r_k} \in E$ for $k = 1,\cdots, n$. We reconstruct the basis $|i_R\>$ (which is of type $\KType(\sigma)$) and $\<i_R|$ (which is of type $\BType(\sigma)$) of $R$ by:
  \begin{itemize}
    \item $R = r_k$, $|i_R\> \triangleq |i_{r_k}\>$ and $\<i_R| \triangleq \<i_{r_k}|$;
    \item $R = (R_1,R_2)$: $|i_R\> \triangleq |i_{R_1}\> \otimes |i_{R_2}\>$ and $\<i_R| \triangleq \<i_{R_1}| \otimes \<i_{R_2}|$.
  \end{itemize}
    \item Expansion of all $K_R,B_R,O_{R,R'}$

    
    After the rewriting of this step, the expression we have is always in the following form:
    $$
    \Big(\sum_{i_1}\cdots\sum_{i_n} a.\tD_f\Big) + \cdots + \Big(\sum_{i_1}\cdots\sum_{i_{n'}} a.\tD_f\Big)
    $$
    where $\tD_f$ is generated by :
    $$\tD_f ::= |i\>_r \mid {}_r\<i| \mid \te\otimes\te \mid \te\cdot\te. $$
    \item
    Suppose $\mathsf{CDom}(\tD_{f}) = \{(i_1,r_1),\cdots,(i_n,r_n)\}$ and $\mathsf{Dom}(\tD_{f}) = \{(i'_1,r'_1),\cdots,(i'_{n'},r'_{n'})\}$ where the list is sorted by a default order of variables in $\cR$. We define:
    $$D_f = \bigg(\prod_{(i,j)\in \mathsf{Can}(\tD_f)}\delta_{i,j}\bigg).\Big((|i_1\>\otimes\cdots\otimes|i_n\>) \cdot (\<i'_1|\otimes\cdots\otimes\<i'_{n'}|)\Big).$$
    If $\mathsf{Dom}$ or $\mathsf{CDom}$ is an empty list, the $D_f$ is just a Ket or Bra.
    Then we claim:
    \begin{itemize}
        \item If $E[\Gamma]\vdash \tD_f : \DType(s_1,s_2)$, then $\{r_1,\cdots,r_n\} = s_1$ and
        $\{r'_1,\cdots,r'_{n'}\} = s_2$.
        \item Set $R = ((\cdots(r_1,r_2),\cdots),r_n)$ and $R' = ((\cdots(r'_1,r'_2),\cdots),r'_{n'})$, then
        $$\tD_{f} = (D_f)_{R,R'}$$
    \end{itemize}
    \item For the obtained formula in (3), we replace each $\tD_f$ by $D_f$ which is computed by step (4). Note that $D_f$ is a Dirac term without labels, so the equivalence of two labelled Dirac terms is reduced to decide the equivalence of two Dirac terms. This is guaranteed if two labelled Dirac terms are of the same type (by typing rules).
\end{enumerate}
