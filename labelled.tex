

\newcommand{\fst}{\mathsf{fst}\ }
\newcommand{\snd}{\mathsf{snd}\ }
\newcommand{\var}{\mathsf{var}\ }
\newcommand{\Var}{\mathsf{Var}\ }
\newcommand{\reg}{\mathsf{Reg}\ }
\newcommand{\DType}{\mathcal{D}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\tD}{\tilde{D}}
\newcommand{\te}{\tilde{e}}
\newcommand{\tT}{\tilde{T}}
\newcommand{\tADD}{\widetilde{ADD}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\<}{\langle}
\newcommand{\simp}{\mathsf{Simp}}
\newcommand{\List}{\mathsf{list}}
\renewcommand{\>}{\rangle}


\section{Labelled Dirac Notation}

\lz{I suggest not adding first and second. Of course, we can, decide this later after discussion.}

\lz{We further only consider constant registers.}

Assume the name set of registers $\cR$.
\begin{definition}[quantum registers]
  \begin{align*}
    R ::= r\in\cR \mid (R, R)
  \end{align*}
\end{definition}

\begin{definition}[register variable set]
The variable set of a register is defined inductively by:
\begin{itemize}
    \item $R\equiv r$: $\var R = \{r\}$;
    \item $R\equiv (R_1,R_2)$: $\var R = \var R_1 \cup\var R_2$.
\end{itemize}  
We define the following relations for quantum registers:
\begin{itemize}
  \item $R$ \textbf{belongs to} $Q$, written as $R\ \text{in}\ Q$, if $\var R\subseteq \var Q$;
  \item $R$ \textbf{is disjoint with} $Q$, written as $R \| Q$, if $\var R \cap \var Q = \emptyset$.
\end{itemize}
\end{definition}

\lz{Since the construction of the quantum register is known, the variable set can be directly computed. Similarly, we use the (computable) set as dependent parameter of the type of Labelled Dirac Term.}

\textbf{Remark: } Set operations: $\cup$ for union; $\cap$ for intersection; $\setminus$ for difference. So,
% \begin{itemize}
$ S_1 \cap S_2 \equiv S_1 \cup S_2 \setminus (S_1 \setminus S_2) \setminus (S_2 \setminus S_1) $.
% \end{itemize}

\begin{definition}[labelled core language]
  The \textbf{labelled core langauge} includes all symbols in the core language of Dirac notation, as well as symbols defined below.
  Here, $s\subseteq \cR$ is the set of register's name, it is computable and thus we do not introduce syntax for it.
  \begin{align*}
    T & ::= \DType(s,s) \mid \mathsf{Reg}(\sigma) \\
    e & ::= R \mid |i\>_r \mid {}_r\<i| \mid e_R \mid e_{R;R} \mid  
    e \otimes e \mid e \cdot e \\
  \end{align*}
  In other words, we don't allow variables for labelled core language for now. In particular, $|i\>_r$ and ${}_r\<i|$ are used as reserved syntax for eliminating registers.
\end{definition}

\subsubsection*{Typing rules}
\lz{context? environment? Since quantum registers are not bound variables, we might just add it to the environment.}

The extra syntax for the environment.
\begin{gather}
    E ::= \dots \mid E; r : \reg(\sigma)
\end{gather}

\subsubsection*{Eliminating the registers}

\begin{enumerate}
  \item For any register $R$ s.t. $E[\Gamma]\vdash R : \reg \sigma$, suppose $\var R = \{r_1,r_2,\cdots,r_n\}$, 
  we introduce variables $i_{r_k} : \Basis(\sigma_{r_k})$ with $r_k : \reg \sigma_{r_k} \in E$ for $k = 1,\cdots, n$. We reconstruct the basis $|i_R\>$ (which is of type $\KType(\sigma)$) and $\<i_R|$ (which is of type $\BType(\sigma)$) of $R$ by:
  \begin{itemize}
    \item $R = r_k$, $|i_R\> \triangleq |i_{r_k}\>$ and $\<i_R| \triangleq \<i_{r_k}|$;
    \item $R = (R_1,R_2)$: $|i_R\> \triangleq |i_{R_1}\> \otimes |i_{R_2}\>$ and $\<i_R| \triangleq \<i_{R_1}| \otimes \<i_{R_2}|$.
  \end{itemize}
    \item Expansion of all $K_R,B_R,O_{R,R'}$

    
    After the rewriting of this step, the expression we have is always in the following form:
    $$
    \Big(\sum_{i_1}\cdots\sum_{i_n} a.\tD_f\Big) + \cdots + \Big(\sum_{i_1}\cdots\sum_{i_{n'}} a.\tD_f\Big)
    $$
    where $\tD_f$ is generated by :
    $$\tD_f ::= |i\>_r \mid {}_r\<i| \mid \te\otimes\te \mid \te\cdot\te. $$
    \item
    Suppose $\mathsf{CDom}(\tD_{f}) = \{(i_1,r_1),\cdots,(i_n,r_n)\}$ and $\mathsf{Dom}(\tD_{f}) = \{(i'_1,r'_1),\cdots,(i'_{n'},r'_{n'})\}$ where the list is sorted by a default order of variables in $\cR$. We define:
    $$D_f = \bigg(\prod_{(i,j)\in \mathsf{Can}(\tD_f)}\delta_{i,j}\bigg).\Big((|i_1\>\otimes\cdots\otimes|i_n\>) \cdot (\<i'_1|\otimes\cdots\otimes\<i'_{n'}|)\Big).$$
    If $\mathsf{Dom}$ or $\mathsf{CDom}$ is an empty list, the $D_f$ is just a Ket or Bra.
    Then we claim:
    \begin{itemize}
        \item If $E[\Gamma]\vdash \tD_f : \DType(s_1,s_2)$, then $\{r_1,\cdots,r_n\} = s_1$ and
        $\{r'_1,\cdots,r'_{n'}\} = s_2$.
        \item Set $R = ((\cdots(r_1,r_2),\cdots),r_n)$ and $R' = ((\cdots(r'_1,r'_2),\cdots),r'_{n'})$, then
        $$\tD_{f} = (D_f)_{R,R'}$$
    \end{itemize}
    \item For the obtained formula in (3), we replace each $\tD_f$ by $D_f$ which is computed by step (4). Note that $D_f$ is a Dirac term without labels, so the equivalence of two labelled Dirac terms is reduced to decide the equivalence of two Dirac terms. This is guaranteed if two labelled Dirac terms are of the same type (by typing rules).
\end{enumerate}
