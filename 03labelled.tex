

% Labelled Dirac Notation

\section{Labelled Dirac Notation}
\label{sec: labelled}



% what is the labelled dirac notation?

% the semantics -- cylinder extension -- uniqueness

% \subsection{Syntax, Typing and Rewriting Rules}

% syntax -- typing -- rules

% \subsection{Normalization}
% normalization -- algorithm that eliminate labels


In this section, we extend the language by allowing quantum variables to indicate the quantum system of vectors and operators it act. 
As discussed, this allows us to express and reason aboud the states and operations locally, without referring to the whole system. 
We further demonstrate how to transform the equivalence problem into that for the Dirac notation studied above.

\subsection{Syntax, Typing, Semantics and Rewriting Rules}
We first introduce the notation of quantum registers for structured variable combinations. This is necessary because, unlike assignments for classical variables, unitary transformations on composite systems -- a quantum version of assignments -- cannot generally be decomposed into separate unitary transformations on individual subsystems.
Let $\cR$ be the set of quantum variables.
%The first new notion is quantum registers, and we assume they are constructed from a set $\cR$.
\begin{definition}[Quantum Register] Register $R$ is inductively generated by
  \begin{align*}
    R ::= r\in\cR \mid (R, R).
  \end{align*}
\end{definition}
For simplicity, we only allow pairing the registers, which corresponds to the structure of tensor product, i.e., $\cH_{(R_1,R_2)}$ is isomorphic to $\cH_{R_1}\otimes \cH_{R_2}$, which allows us to view the tensor product space as the space of paired registers.

The no-cloning theorem, a fundamental property of quantum computing, prevents us from copying an unknown quantum state. This requires an additional check on the valid registers -- they should not include repeated quantum variables -- which is often handled in programming languages via linear types. Here, we start from the basic definition of \emph{order-free} variable set of a register:
\begin{definition}
The variable set of a register is defined inductively by:
\begin{itemize}
    \item $\var(R) = \{r\}$, if $R\equiv r$; or
    \item $\var(R) = \var(R_1) \cup\var(R_2)$, if $R\equiv (R_1,R_2)$.
\end{itemize}
\end{definition}

% \textbf{Remark: } Set operations: $\cup$ for union; $\cap$ for intersection; $\setminus$ for difference. So,
% % \begin{itemize}
% $ S_1 \cap S_2 \equiv S_1 \cup S_2 \setminus (S_1 \setminus S_2) \setminus (S_2 \setminus S_1) $.
% \end{itemize}

% The labelled Dirac notation is an extension on the existing type and syntax.
Now, we are ready to extend the type syntax and term syntax as follows:
\begin{definition}[Labelled Dirac Notation]
  The \textbf{labelled Dirac notation} includes all Dirac notation symbols and the generators defined below.
  Here, $s\subseteq \cR$ is a quantum variable set.
  \begin{align*}
    T & ::= \DType(s,s) \mid \mathsf{Reg}(\sigma) \\
    e & ::= R \mid |i\>_r \mid {}_r\<i| \mid e_R \mid e_{R;R} \mid
    e \otimes e \otimes \cdots \otimes e \mid e \cdot e.
  \end{align*}
\end{definition}
$\DType(s_1, s_2)$ is the unified type for all labelled Dirac notation, where $s_1$ indicates the codomain systems and $s_2$ indicates the domain systems. For instance, labelled ket $|i\>_r$ has type $\DType(\{r\}, \emptyset)$, and labelled bra ${}_r\<i|$ has type $\DType(\emptyset, \{r\})$.
$\reg(\sigma)$ are types for registers $R$, and the index $\sigma$ indicates the type of Hilbert space represented by the register.
It is allowed to lift a Dirac notation associate with corresponding quantum variables or registers, e.g., $\ket{i}_r$ and ${}_r\bra{i}$ are labelled basis, 
$e_R$ for bra, ket and $e_{R;R}$ for operators. 
We further introduce new $\cdot$ for generalized composition (unified for all kinds of multiplications between kets, bras and operators) and $\otimes$ for labelled tensor product since they do not share the same properties v.s. its counterpart in Dirac notation, i.e., generalized composition is not associative and labelled tensor is indeed an AC symbol.
% In labelled Dirac notation, the structure of tensor product does not matter, therefore $\otimes$ is an AC symbol.
% Following the unified type $\DType(s,s)$, all kinds of multiplications are represented by the same dot product $e \cdot e$.
% Finally, $\ket{i}_r$ and ${}_r\bra{i}$ are labelled basis for the normal form of labelled Dirac notation, where $r$ are registers symbols in $\mathcal{R}$. 

\paragraph*{Typing rules.}
There are various rules for computing types and checking vadility of registers and labelled terms. Here we display some of the rules and see Appendix for all the rest.
\begin{gather*}
  \frac{
      E \vdash R : \reg(\sigma) \quad
      E \vdash Q : \reg(\tau)
      \quad \var(R) \cap \var(Q) = \emptyset
  }{E \vdash (R,Q) : \reg(\sigma \times \tau)} \\[0.2cm]
  \frac{
          E \vdash r : \reg(\sigma) \quad
          E \vdash i : \Basis(\sigma)}
  {E \vdash |i\>_r : \DType(\{r\}, \emptyset)}
  \qquad
  \frac{E \vdash R : \reg(\sigma)\qquad E \vdash K : \KType(\sigma)}{E \vdash K_R : \DType(\var(R), \emptyset)} \\[0.2cm]
    \frac{
        E \vdash D_i : \DType(s_i,s_i') \qquad
        \forall\,i\neq j.\ s_i\cap s_j = \emptyset \qquad
        \forall\,i\neq j.\ s'_i\cap s'_j = \emptyset
    }
    {E \vdash D_1 \otimes \cdots \otimes D_i : \DType(\bigcup_i s_i, \bigcup_i s_i')}.
\end{gather*}
The first rule says that a paired register is of the product type and its components should be disjoint.
Once we lift a Dirac notation to the labelled one (line 2), we enforce that the term and register are of the same indices, reflecting the fact the state should be consistant to the corresponding subsystems.
The third line gives the typing of labelled tensoring with a check whether the component subsystems are disjoint with each other.

% \[
%     \frac{
%         \begin{aligned}
%             E \vdash D_1 : \DType(s_1,s_1') \\
%             E \vdash D_2 : \DType(s_2,s_2')
%         \end{aligned}
%         \qquad 
%         \begin{aligned}
%             s_1 \cap s_2 \backslash s_1' = \emptyset \\
%             s_2' \cap s_1' \backslash s_2 = \emptyset
%         \end{aligned}
%     }
%     {E \vdash D_1\cdot D_2 : \DType(s_1 \cup (s_2\backslash s_1'), s_2' \cup (s_1'\backslash s_2))}.
% \]

% Some typing rules are introduced here.
% The rule for $\DType(s_1, s_2)$ requires that all registers in variable set $s_1$ and $s_2$ are well-typed.
% The rule for $K_R$ demonstrates how a register label is added to the Dirac notation, and the rule for $D^\dagger$ shows that labelled Dirac notation also have symbols for calculation, such as the adjoint.
% \[
%     \frac{E \vdash  \sigma : \Index}{E \vdash \reg(\sigma) : \Type}
%     \qquad
%     \frac{E \vdash r : \reg(\sigma_r) \text{ for all $r$ in $s_1$ and $s_2$} }{E \vdash \DType(s_1, s_2) : \textsf{Type}} 
% \]
% \[
%     \frac{E \vdash R : \reg(\sigma)\qquad E \vdash K : \KType(\sigma)}{E \vdash K_R : \DType(\var R, \emptyset)}
%     \qquad
%     \frac{E \vdash D : \DType(s_1,s_2)}{E \vdash D^\dagger : \DType(s_2,s_1)}
% \]
% The dot and the tensor product symbols are different from those in unlabelled Dirac notation. Since the goal of labels is to replace the order and structure of tensor products by the reference to registers, the tensor product becomes an AC symbol. The typing still checks whether the component subsystems are disjoint with each other.
% \[
%     \frac{
%         E \vdash D_i : \DType(s_i,s_i') \qquad
%         \bigcap_i s_i = \emptyset \qquad
%         \bigcap_i s_i' = \emptyset
%     }
%     {E \vdash D_1 \otimes \cdots \otimes D_i : \DType(\bigcup_i s_i, \bigcup_i s_i')}.
% \]
% As for the dot product, the disjointness is considered except registers contracted by multiplication.
% \[
%     \qquad
%     \frac{
%         \begin{aligned}
%             E \vdash D_1 : \DType(s_1,s_1') \\
%             E \vdash D_2 : \DType(s_2,s_2')
%         \end{aligned}
%         \qquad 
%         \begin{aligned}
%             s_1 \cap s_2 \backslash s_1' = \emptyset \\
%             s_2' \cap s_1' \backslash s_2 = \emptyset
%         \end{aligned}
%     }
%     {E \vdash D_1\cdot D_2 : \DType(s_1 \cup (s_2\backslash s_1'), s_2' \cup (s_1'\backslash s_2))}.
% \]

\paragraph*{Semantics} While the labelled Dirac notation avoid unnecessary lifting and ordering, its semantics faithfully capture these details. The key points are 1. cylindrical extension that lift a ket or bra or operator to any larger domain and codomain; 2. general composition further employs cylindrical extension obeys the principle of ``localizing objects as much as possible''~\cite{Zhou2023}.


\subsubsection{Normalization}
The normalization procedure of Dirac notation is extended to check equivalence with labels.
We add rules to the term rewriting system, which in general try to represent labelled Dirac notation with labelled basis and scalar coefficients. The first step is the label elimination. Take operator as an example:
\begin{align*}
    & O_{R,R'} \ \reduce\ \sum_{i_{r_1}\in\bU(\sigma_{r_1})}\cdots \sum_{i_{r_n}\in\bU(\sigma_{r_n})}
    \sum_{i_{r'_1}\in\bU(\sigma_{r'_1})}\cdots \sum_{i_{r'_{n'}}\in\bU(\sigma_{r'_{n'}})} \\
    & \qquad (\<i_R|\cdot O\cdot |i_{R'}\>).(|i_{r_1}\>_{r_i}\otimes\cdots\otimes|i_{r_n}\>_{r_n} \otimes {}_{r'_1}\<i_{r'_1}|\otimes\cdots\otimes{}_{r'_{n'}}\<i_{r'_{n'}}|).
\end{align*}
The rules for $e_R$ (ket and bra) are similar. This step reduces all labelled terms $e_R$ or $e_{R;R}$.
Other symbols on labelled Dirac notation are also reduced by rules like $(D_1 \cdot D_2)^\dagger \ \reduce\ D_2^\dagger \cdot D_1^\dagger$.
The final step operates on sum and dot product. They will lift summation to the outside, and eliminate the bra-ket pairs whenever possible.
\begin{align*}
    & \textrm{(R-SUM-PUSHD0)}
    && X_1 \otimes \cdots (\sum_{i \in M} D) \cdots \otimes X_2\ \reduce\ \sum_{i \in M} (X_1 \otimes \cdots D \cdots \otimes X_n) \\
    % %
    % & \textrm{(R-SUM-PUSHD1)}
    % && (\sum_{i \in M} D_1) \cdot D_2 \ \reduce\ \sum_{i \in M} (D_1 \cdot D_2) \\
    %
    & \textrm{(R-L-SORT0)}
    && A : \DType(s_1, s_2), B : \DType(s_1', s_2'), s_2 \cap s_1'=\emptyset \Rightarrow A \cdot B \ \reduce\ A \otimes B \\
    %
    & \textrm{(R-L-SORT1)}
    && {}_r\bra{i}\cdot\ket{j}_r \ \reduce\ \delta_{i, j} \\
    %
    & \textrm{(R-L-SORT2)}
    && {}_r\bra{i}\cdot(Y_1 \otimes \cdots \otimes \ket{j}_r \otimes \cdots \otimes Y_m) \ \reduce\ \delta_{i, j}.(Y_1  \otimes \cdots \otimes Y_m)
    %
\end{align*}
% These rules are added to the rewriting system in~\Cref{sec: decide} and executed together.
In the end, if there are no variables of $\DType(s_1, s_2)$, the expression will be reduced to the addition of big operator sum, and each sum body is labelled basis with Dirac notation scalar coefficients:
\[
    \sum_{i}\cdots\sum_{j} a_1 . (\ket{i}_{p} \otimes \cdots \otimes \bra{j}_{q})
    + \cdots +
    \sum_{k}\cdots\sum_{l} a_m . (\ket{k}_{r} \otimes \cdots \otimes \bra{l}_{s})
\]
In this stage, we only need to check the scalars to decide the equivalence of labelled Dirac notation.

% \begin{lemma}[normal form]
%     \label{lem: labelled normal form}
%     For a well-typed term $e$ in $E[\Gamma]$, if $e$ does not contain variables of $\DType(s_1, s_2)$ type, the normal form of $e$ will be
%     \[
%     \sum_{i}\cdots\sum_{j} a_1 . (\ket{i}_{p} \otimes \cdots \otimes \bra{j}_{q})
%     + \cdots +
%     \sum_{k}\cdots\sum_{l} a_m . (\ket{k}_{r} \otimes \cdots \otimes \bra{l}_{s})
%     \]
%     Where $a_i$ are scalar typed Dirac notation.
% \end{lemma}
% \begin{proof}
%     Labelled Dirac notation of $e_R$, $e_R;R$, 
% \end{proof}
