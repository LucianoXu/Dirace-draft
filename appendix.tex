
\section{Full Typing Rules}

\label{sec: full typing rules}

This section includes the full list of typing rules.

\begin{itemize}
    \item Rules for a well-formed context.
    \[
        \textbf{W-Empty} \qquad
        \frac{}{\WF([])}
    \]
    \[
        \textbf{W-Assum-Index} \qquad
        \frac{\WF(\Gamma) \qquad}{\WF(\Gamma; x : \Index)}
    \]
    \[
        \textbf{W-Assum-Term} \qquad
        \frac{\Gamma \vdash T : \Type}{\WF(\Gamma; x:T)}
    \]
    \[
        \textbf{W-Def-Term} \qquad
        \frac{\Gamma \vdash t:T \qquad x \notin \Gamma}{\WF(\Gamma; x:=t:T)}
    \]

    \item Rules for type indices.
    \[
        \textbf{Index-Var} \qquad
        \frac{\WF(\Gamma) \qquad x : \Index \in \Gamma}{\Gamma \vdash x : \Index}
    \]
    \[
        \textbf{Index-Prod} \qquad
        \frac{\Gamma \vdash \sigma : \Index \qquad \Gamma \vdash \tau : \Index}{\Gamma \vdash \sigma \times \tau : \Index}
    \]
    \[
        \textbf{Index-Qudit} \qquad
        \frac{\WF(\Gamma)}{\Gamma \vdash \mathsf{bool} : \Index}
    \]


    \item Rules for types.
    \[
        \textbf{Type-Lam} \qquad
        \frac{\Gamma \vdash T : \Type \qquad \Gamma \vdash U : \Type}{\Gamma \vdash T \to U : \Type}
    \]
    \[
        \textbf{Type-Index} \qquad
        \frac{\Gamma; x : \Index \vdash U : \Type}{\Gamma \vdash \forall x.U : \Type}
    \]
    \[
        \textbf{Type-Basis} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \Basis(\sigma) : \Type}
    \]
    \[
        \textbf{Type-Ket} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \KType(\sigma) : \Type}
    \]
    \[
        \textbf{Type-Bra} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \BType(\sigma) : \Type}
    \]
    \[
        \textbf{Type-Opt} \qquad
        \frac{\Gamma \vdash \sigma : \Index \qquad \Gamma \vdash \tau : \Index}{\Gamma \vdash \OType(\sigma, \tau) : \Type}
    \]
    \[
        \textbf{Type-Scalar} \qquad
        \frac{\WF(\Gamma)}{\Gamma \vdash \SType : \Type}
    \]
    \[
        \textbf{Type-Set} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \SET(\sigma) : \Type}
    \]
    \[
        \textbf{Type-Register} \qquad
        \frac{\Gamma \vdash  \sigma : \Index}{\Gamma \vdash \reg(\sigma) : \Type}
    \]
    \[
        \textbf{Type-Labelled} \qquad
        \frac{\Gamma \vdash r : \reg(\sigma_r) \text{ for all $r$ in $s_1$ and $s_2$} }{\Gamma \vdash \DType(s_1, s_2) : \textsf{Type}} 
    \]

    \item Rules for variable and function typings. Here $U\{x/u\}$ means replacing the bound variable $x$ with $u$ in $U$.
    \[
        \textbf{Term-Var} \qquad
        \frac{
            \begin{aligned}
                & \WF(\Gamma) \\
                & (x:T) \in \Gamma \text{ or } (x := t : T) \in \Gamma \text{ for some $t$}
            \end{aligned}
        }
        {\Gamma \vdash x : T}
    \]
    \[
        \textbf{Lam} \qquad
        \frac{\Gamma; x : T \vdash t : U}{\Gamma \vdash (\lambda x : T . t) : T \to U}
    \]
    \[
        \textbf{Index} \qquad
        \frac{\Gamma; x : \Index \vdash t : U}{\Gamma \vdash (\lambda x : T.t) : \forall x.U}
    \]
    \[
        \textbf{App-Lam} \qquad
        \frac{\Gamma \vdash t:U \to T \qquad \Gamma \vdash u:U}{\Gamma \vdash (t\ u):T}
    \]
    \[
        \textbf{App-Index} \qquad
        \frac{\Gamma \vdash t:\forall x.U \qquad \Gamma \vdash u : \Index}{\Gamma \vdash (t\ u):U\{x/u\}}
    \]
    
    \item Basis term typing rules. 
    \[  \textbf{Basis-0} \qquad
        \frac{\WF(\Gamma)}{\Gamma \vdash 0 : \Basis(\mathsf{bool})}
    \]
    \[  \textbf{Basis-1} \qquad
        \frac{\WF(\Gamma)}{\Gamma \vdash 1 : \Basis(\mathsf{bool})}
    \]
    \[
        \textbf{Basis-Pair} \qquad
        \frac{\Gamma\vdash s : \Basis(\sigma) \qquad \Gamma\vdash t : \Basis(\tau)} {\Gamma\vdash (s, t) : \Basis(\sigma \times \tau)}
    \]


    \item Composition typing rules. 
    \[  \textbf{Compo-SS} \qquad
        \frac{\Gamma \vdash x : \SType \qquad \Gamma \vdash y : \SType}{\Gamma \vdash x \circ y : \SType}
    \]
    \[  \textbf{Compo-SK} \qquad
        \frac{\Gamma \vdash x : \SType \qquad \Gamma \vdash y : \KType(\sigma)}{\Gamma \vdash x \circ y : \KType(\sigma)}
    \]
    \[  \textbf{Compo-SB} \qquad
        \frac{\Gamma \vdash x : \SType \qquad \Gamma \vdash y : \BType(\sigma)}{\Gamma \vdash x \circ y : \BType(\sigma)}
    \]
    \[  \textbf{Compo-SO} \qquad
        \frac{\Gamma \vdash x : \SType \qquad \Gamma \vdash y : \OType(\sigma, \tau)}{\Gamma \vdash x \circ y : \OType(\sigma, \tau)}
    \]
    \[  \textbf{Compo-KS} \qquad
        \frac{\Gamma \vdash x : \KType(\sigma) \qquad \Gamma \vdash y : \SType}{\Gamma \vdash x \circ y : \KType(\sigma)}
    \]
    \[  \textbf{Compo-KK} \qquad
        \frac{\Gamma \vdash x : \KType(\sigma) \qquad \Gamma \vdash y : \KType(\tau)}{\Gamma \vdash x \circ y : \KType(\sigma \times \tau)}
    \]
    \[  \textbf{Compo-KB} \qquad
        \frac{\Gamma \vdash x : \KType(\sigma) \qquad \Gamma \vdash y : \BType(\tau)}{\Gamma \vdash x \circ y : \OType(\sigma, \tau)}
    \]
    \[  \textbf{Compo-BS} \qquad
        \frac{\Gamma \vdash x : \BType(\sigma) \qquad \Gamma \vdash y : \SType}{\Gamma \vdash x \circ y : \BType(\sigma)}
    \]
    \[  \textbf{Compo-BK} \qquad
        \frac{\Gamma \vdash x : \BType(\sigma) \qquad \Gamma \vdash y : \KType(\sigma)}{\Gamma \vdash x \circ y : \SType}
    \]
    \[  \textbf{Compo-BB} \qquad
        \frac{\Gamma \vdash x : \BType(\sigma) \qquad \Gamma \vdash y : \BType(\tau)}{\Gamma \vdash x \circ y : \BType(\sigma \times \tau)}
    \]
    \[  \textbf{Compo-BO} \qquad
        \frac{\Gamma \vdash x : \BType(\sigma) \qquad \Gamma \vdash y : \OType(\sigma, \tau)}{\Gamma \vdash x \circ y : \BType(\tau)}
    \]
    \[  \textbf{Compo-OS} \qquad
        \frac{\Gamma \vdash x : \OType(\sigma, \tau) \qquad \Gamma \vdash y : \SType}{\Gamma \vdash x \circ y : \OType(\sigma, \tau)}
    \]
    \[  \textbf{Compo-OK} \qquad
        \frac{\Gamma \vdash x : \OType(\sigma, \tau) \qquad \Gamma \vdash y : \KType(\tau)}{\Gamma \vdash x \circ y : \KType(\sigma)}
    \]
    \[  \textbf{Compo-OO} \qquad
        \frac{\Gamma \vdash x : \OType(\sigma, \tau) \qquad \Gamma \vdash y : \OType(\sigma', \tau')}{\Gamma \vdash x \circ y : \OType(\sigma \times \sigma', \tau \times \tau')}
    \]
    \[
        \textbf{Compo-DD} \qquad
        \frac{
            \begin{aligned}
                \Gamma \vdash x : \DType(s_1,s_1') \\
                \Gamma \vdash y : \DType(s_2,s_2')
            \end{aligned}
            \qquad 
            \begin{aligned}
                s_1 \cap s_2 \backslash s_1' = \emptyset \\
                s_2' \cap s_1' \backslash s_2 = \emptyset
            \end{aligned}
        }
        {\Gamma \vdash x\circ y : \DType(s_1 \cup (s_2\backslash s_1'), s_2' \cup (s_1'\backslash s_2))}
    \]


    \item Scalar term typing rules.
    \[
        \textbf{Sca-0} \qquad
        \frac{\WF(\Gamma)}{\Gamma \vdash 0 : \SType}
    \]
    \[
        \textbf{Sca-1} \qquad
        \frac{\WF(\Gamma)}{\Gamma \vdash 1 : \SType}
    \]
    \[
        \textbf{Sca-Delta} \qquad
        \frac{ \Gamma\vdash s : \Basis(\sigma) \qquad \Gamma\vdash t : \Basis(\sigma) } {\Gamma \vdash \delta_{s, t} : \SType}
    \]
    \[
        \textbf{Sca-Add} \qquad
        \frac{\Gamma\vdash a_i : \SType \text{ for all $i$}}{\Gamma\vdash a_1 + \cdots + a_n : \SType}
    \]
    \[
        \textbf{Sca-Mul} \qquad
        \frac{\Gamma\vdash a_i : \SType \text{ for all $i$}}{\Gamma\vdash a_1 \times \cdots \times a_n : \SType}
    \]
    \[
        \textbf{Sca-Conj} \qquad
        \frac{\Gamma \vdash a : \SType}{\Gamma \vdash a^*:\SType}
    \]
    \[
        \textbf{Sca-Dot} \qquad
        \frac{\Gamma\vdash B : \BType(\sigma) \qquad \Gamma\vdash K : \KType(\sigma)}{\Gamma \vdash B \cdot K : \SType}
    \]
    \[
        \textbf{Sca-Sum} \qquad
        \frac{\Gamma \vdash s : \SET(\sigma) \qquad \Gamma \vdash f : \Basis(\sigma) \to \SType}{\Gamma \vdash \sum_{s} f : \SType}
    \]

    \item Ket term typing rules.
    \[
        \textbf{Ket-0} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \ZEROK(\sigma) : \KType(\sigma)}
    \]
    \[
        \textbf{Ket-Basis} \qquad
        \frac{\Gamma\vdash t : \Basis(\sigma)}{\Gamma \vdash \ket{t} : \KType(\sigma)}
    \]
    \[
        \textbf{Ket-Adj} \qquad
        \frac{\Gamma \vdash B : \BType(\sigma)}{\Gamma \vdash B^\dagger : \KType(\sigma)}
    \]
    \[
        \textbf{Ket-Scr} \qquad
        \frac{\Gamma \vdash a : \SType \qquad \Gamma \vdash K : \KType(\sigma)}{\Gamma \vdash a.K : \KType(\sigma)}
    \]
    \[
        \textbf{Ket-Add} \qquad
        \frac{\Gamma \vdash K_i : \KType(\sigma) \text{ for all $i$}}{\Gamma \vdash K_1 + \cdots + K_n : \KType(\sigma)}
    \]
    \[
        \textbf{Ket-MulK} \qquad
        \frac{\Gamma \vdash O : \OType(\sigma, \tau) \qquad \Gamma \vdash K : \KType(\tau)}{\Gamma \vdash O \cdot K : \KType(\sigma)}
    \]
    \[
        \textbf{Ket-Tsr} \qquad
        \frac{\Gamma \vdash K_1 : \KType(\sigma) \qquad \Gamma \vdash K_2 : \KType(\tau)} {\Gamma \vdash K_1 \otimes K_2 : \KType(\sigma \times \tau)}
    \]
    \[
        \textbf{Ket-Sum} \qquad
        \frac{\Gamma \vdash s : \SET(\sigma) \qquad \Gamma \vdash f : \Basis(\sigma) \to \KType(\tau)}{\Gamma \vdash \sum_{s} f : \KType(\tau)}
    \]

    \item Bra term typing rules.
    \[
        \textbf{Bra-0} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \ZEROB(\sigma) : \BType(\sigma)}
    \]
    \[
        \textbf{Bra-Basis} \qquad
        \frac{\Gamma\vdash t : \Basis(\sigma)}{\Gamma \vdash \bra{t} : \BType(\sigma)}
    \]
    \[
        \textbf{Bra-Adj} \qquad
        \frac{\Gamma \vdash K : \KType(\sigma)}{\Gamma \vdash K^\dagger : \BType(\sigma)}
    \]
    \[
        \textbf{Bra-Scr} \qquad
        \frac{\Gamma \vdash a : \SType \qquad \Gamma \vdash B : \BType(\sigma)}{\Gamma \vdash a.B : \BType(\sigma)}
    \]
    \[
        \textbf{Bra-Add} \qquad
        \frac{\Gamma \vdash B_i : \BType(\sigma) \text{ for all $i$}}{\Gamma \vdash B_1 + \cdots + B_n : \BType(\sigma)}
    \]
    \[
        \textbf{Bra-MulB} \qquad
        \frac{\Gamma \vdash B : \KType(\sigma) \qquad \Gamma \vdash O : \OType(\sigma, \tau)}{\Gamma \vdash B \cdot O : \BType(\tau)}
    \]
    \[
        \textbf{Bra-Tsr} \qquad
        \frac{\Gamma \vdash B_1 : \BType(\sigma) \qquad \Gamma \vdash B_2 : \BType(\tau)} {\Gamma \vdash B_1 \otimes B_2 : \BType(\sigma \times \tau)}
    \]
    \[
        \textbf{Bra-Sum} \qquad
        \frac{\Gamma \vdash s : \SET(\sigma) \qquad \Gamma \vdash f : \Basis(\sigma) \to \BType(\tau)}{\Gamma \vdash \sum_{s} f : \BType(\tau)}
    \]

    \item Operator term typing rules.
    \[
        \textbf{Opt-0} \qquad
        \frac{\Gamma \vdash \sigma : \Index \qquad \Gamma \vdash \tau : \Index}{\Gamma \vdash \ZEROO(\sigma, \tau) : \OType(\sigma, \tau)}
    \]
    \[
        \textbf{Opt-1} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \ONEO(\sigma) : \OType(\sigma, \sigma)}
    \]
    \[
        \textbf{Opt-Adj} \qquad
        \frac{\Gamma \vdash O : \OType(\sigma, \tau)}{\Gamma \vdash O^\dagger : \OType(\tau, \sigma)}
    \]
    \[
        \textbf{Opt-Scr} \qquad
        \frac{\Gamma \vdash a : \SType \qquad \Gamma \vdash O : \OType(\sigma, \tau)}{\Gamma \vdash a.O : \OType(\sigma, \tau)}
    \]
    \[
        \textbf{Opt-Add} \qquad
        \frac{\Gamma \vdash O_i : \OType(\sigma, \tau) \text{ for all $i$}}{\Gamma \vdash O_1 + \cdots + O_n : \OType(\sigma, \tau)}
    \]
    \[
        \textbf{Opt-Outer} \qquad
        \frac{\Gamma\vdash K : \KType(\sigma) \qquad \Gamma\vdash B : \BType(\tau)}{\Gamma\vdash K \cdot B : \OType(\sigma, \tau)}
    \]
    \[
        \textbf{Opt-Mulo} \qquad
        \frac{\Gamma \vdash O_1 : \OType(\sigma, \tau) \qquad \Gamma \vdash O_2 : \OType(\tau, \rho)}{\Gamma \vdash O_1 \cdot O_2 : \OType(\sigma, \rho)}
    \]
    \[
        \textbf{Opt-Tsr} \qquad
        \frac{\Gamma \vdash O_1 : \OType(\sigma_1, \tau_1) \qquad \Gamma \vdash O_2 : \OType(\sigma_2, \tau_2)} {\Gamma \vdash O_1 \otimes O_2 : \OType(\sigma_1 \times \sigma_2, \tau_1 \times \tau_2)}
    \]
    \[
        \textbf{Opt-Sum} \qquad
        \frac{\Gamma \vdash s : \SET(\sigma) \qquad \Gamma \vdash f : \Basis(\sigma) \to \OType(\tau, \rho)}{\Gamma \vdash \sum_{s} f : \OType(\tau, \rho)}
    \]

    \item Set term typing rules.
    \[
        \textbf{Set-U} \qquad
        \frac{\Gamma \vdash \sigma : \Index}{\Gamma \vdash \mathbf{U}(\sigma) : \SET(\sigma)}
    \]
    \[
        \textbf{Set-Prod} \qquad
        \frac{\Gamma \vdash A : \SET(\sigma) \qquad \Gamma \vdash B : \SET(\tau)}{\Gamma \vdash A \star B : \SET(\sigma \times \tau)}
    \]


    \item Register term typing rules.
    \[
        \textbf{Reg-Var} \qquad
        \frac{\WF(\Gamma) \qquad r : \reg(\sigma) \in \Gamma}{\Gamma \vdash r : \reg(\sigma)}
    \]
    \[
        \textbf{Reg-Pair}\qquad
        \frac{
            \begin{aligned}
                \Gamma \vdash R : \reg(\sigma) \\
                \Gamma \vdash Q : \reg(\tau)
            \end{aligned}
            \qquad \var(R) \cap \var(Q) = \emptyset
        }{\Gamma \vdash (R,Q) : \reg(\sigma \times \tau)}
    \]

    \item Typing rules for labelled Dirac notation.
    \[
        \textbf{L-Basis-Ket}\qquad 
        \frac{r : \reg(\sigma) \in \Gamma\qquad \Gamma \vdash i : \Basis(\sigma)}{\Gamma \vdash |i\>_r : \DType(\{r\}, \emptyset)}
    \]
    \[
        \textbf{L-Basis-Bra}\qquad 
        \frac{r : \reg(\sigma) \in \Gamma \qquad \Gamma \vdash i : \Basis(\sigma)}{\Gamma \vdash {}_r\<i| : \DType(\emptyset, \{r\})}
    \]
    \[
        \textbf{L-Ket}\qquad 
        \frac{\Gamma \vdash R : \reg(\sigma)\qquad \Gamma \vdash K : \KType(\sigma)}{\Gamma \vdash K_R : \DType(\var R, \emptyset)}
    \]
    \[
        \textbf{L-Bra}\qquad 
        \frac{\Gamma \vdash R : \reg(\sigma)\qquad \Gamma \vdash B : \BType(\sigma)}{\Gamma \vdash B_R : \DType(\emptyset, \var R)}
    \]
    \[
        \textbf{L-Opt}\qquad 
        \frac{
            \begin{aligned}
                \Gamma \vdash R_1 : \reg (\sigma_1) \\
                \Gamma \vdash R_2 : \reg (\sigma_2)
            \end{aligned}
            \qquad
            \Gamma \vdash O : \OType(\sigma_1, \sigma_2)
        }
        {\Gamma \vdash O_{R_1;R_2} : \DType(\var R_1, \var R_2)}
    \]
    \[
        \textbf{L-Conj}\qquad 
        \frac{\Gamma \vdash D : \DType(s_1,s_2)}{\Gamma \vdash D^\dagger : \DType(s_2,s_1)}
    \]
    \[
        \textbf{L-Scl}\qquad 
        \frac{\Gamma \vdash S : \SType\qquad \Gamma \vdash D : \DType(s_1,s_2)}{\Gamma \vdash S.D : \DType(s_1,s_2)}
    \]
    \[
        \textbf{L-Add}\qquad
        \frac{\Gamma \vdash D_i : \DType(s_1,s_2)\quad \text{forall } i}{\Gamma \vdash D_1+\cdots+D_n : \DType(s_1,s_2)}
    \]
    \[
        \textbf{L-Tsr}\qquad
        \frac{
            \Gamma \vdash D_i : \DType(s_i,s_i') \qquad
            \bigcap_i s_i = \emptyset \qquad
            \bigcap_i s_i' = \emptyset
        }
        {\Gamma \vdash D_1 \otimes \cdots \otimes D_i : \DType(\bigcup_i s_i, \bigcup_i s_i')}
    \]
    \[
        \textbf{L-Dot}\qquad
        \frac{
            \begin{aligned}
                \Gamma \vdash D_1 : \DType(s_1,s_1') \\
                \Gamma \vdash D_2 : \DType(s_2,s_2')
            \end{aligned}
            \qquad 
            \begin{aligned}
                s_1 \cap s_2 \backslash s_1' = \emptyset \\
                s_2' \cap s_1' \backslash s_2 = \emptyset
            \end{aligned}
        }
        {\Gamma \vdash D_1\cdot D_2 : \DType(s_1 \cup (s_2\backslash s_1'), s_2' \cup (s_1'\backslash s_2))}
    \]
    \[
        \textbf{L-Sum}\qquad
        \frac{\Gamma \vdash s : \SET(\sigma) \qquad \Gamma \vdash f : \Basis(\sigma) \to \DType(s_1, s_2)}{\Gamma \vdash \sum_{s} f : \DType(s_1, s_2)}
    \]

\end{itemize}

\section{Denotational Semantics}
\label{sec: full denotational sem}

\begin{definition}[Interpretation of indices]
The interpretation $\sem{\sigma}$ of a index is defined inductively as follows:
    \begin{align*}
        & \textrm{(Basis types)} &&
        \sem{\sigma_1 \times \sigma_2} \equiv \sem{\sigma_1} \times \sem{\sigma_2}.
     \end{align*}
\end{definition}

\begin{definition}[Interpretation of types]
The interpretation $\sem{T}$ of a type is defined inductively as follows:
\begin{align*}
    & \text{(Basis types)} && \begin{aligned}
      & \sem{\Basis(\sigma)} \equiv \sem{\sigma},
 \end{aligned} \\
    & \text{(Dirac types)} &&
 \sem{\SType} \equiv \mathbb{C},
 \qquad
 \sem{\KType(\sigma)} \equiv \mathcal{H}_{\sem{\sigma}}, 
 \qquad
 \sem{\BType(\sigma)} \equiv \mathcal{H}^*_{\sem{\sigma}},
      \\ & &&
 \sem{\OType(\sigma, \tau)} \equiv \mathcal{L}(\mathcal{H}_\sem{\tau}, \mathcal{H}_\sem{\sigma})
    \\
    % & \text{(Function types)} &&
    % \sem{T_1 \to T_2} \equiv \sem{T_2}^\sem{T_1}
    % \qquad
    % \sem{\forall x.T} \equiv \sem{T}^I \\
    & \text{(Set types)} &&
    \sem{\SET(\sigma)} = \mathcal{P}(\sem{\sigma}) \\
    & \text{(Labelled Dirac types)} &&
    \sem{\cD(s,s')} = \mathcal{L}(\bigotimes_{j}\cH_{\sem{\sigma_{r'_j}}_v}, \bigotimes_{i}\cH_{\sem{\sigma_{r_i}}_v})
\end{align*}
where the sets $s = \{r_1,\cdots,r_n\}$ and $s' = \{r'_1,\cdots,r'_m\}$ ($r_i$ and $r'_j$ are sorted) and $\Gamma \vdash r_i : \reg(\sigma_{r_i})$, $\Gamma \vdash r'_j : \reg(\sigma_{r'_j})$.
\end{definition}
% \gb{did we already explain the notations?}\lz{not ready. the paragraph explains this has been removed.}\gb{please add it back somewhere if space}

We now turn to the interpretation of expressions. As usual, the interpretation is parametrized by a valuation \(v\), which maps all variables $x$ to their value $v(x)$. 

For any set $s = \{r_1,r_2,\cdots,r_n\}$ ($r_i$ is ordered) with $\Gamma \vdash r_i : \reg(\sigma_{r_i})$, we define 
$$\mathbf{1}_s \triangleq (\mathbf{1}_{\mathcal{O}}(\sigma_{r_1}))_{r_1}\otimes\cdots(\mathbf{1}_{\mathcal{O}}(\sigma_{r_n}))_{r_n}.$$
For any register $R$ s.t. $\Gamma\vdash R : \reg(\sigma)$, suppose $\var(R) = \{r_1,r_2,\cdots,r_n\}$ ($r_i$ is ordered), 
we introduce variables $i_{r_k} : \Basis(\sigma_{r_k})$ with $\Gamma \vdash r_k : \reg(\sigma_{r_k})$ for $k = 1,\cdots, n$. 
We reconstruct the basis $|i_R\>$ (which is of type $\KType(\sigma)$) and $\<i_R|$ (which is of type $\BType(\sigma)$) of $R$ by:
\begin{itemize}
  \item $R = r_k$, $|i_R\> \triangleq |i_{r_k}\>$ and $\<i_R| \triangleq \<i_{r_k}|$;
  \item $R = (R_1,R_2)$: $|i_R\> \triangleq |i_{R_1}\> \otimes |i_{R_2}\>$ and $\<i_R| \triangleq \<i_{R_1}| \otimes \<i_{R_2}|$.
\end{itemize}
Now, we can define the operator $\Swap_R$ that sorts $R$ as: 
$$\Swap_R = \sum_{i_{r_1}}\cdots\sum_{i_{r_n}} (|i_{r_1}\>\otimes\cdots|i_{r_n}\>)\cdot(\<i_R|).$$
Similarly, we define $\Swap_{s_1,s_2,\cdots,s_n}$ for merging disjoint sets orderly. Suppose $s_i = \{r_{i1},\cdots r_{im_i}\}$ (ordered enumerated), and sorted $\bigcup_i\{r_{i1},\cdots r_{im_i}\}$ as $\{r_1,\cdots,r_k\}$, then  
$$\Swap_R = \sum_{i_{r_1}}\cdots\sum_{i_{r_k}} (|i_{r_1}\>\otimes\cdots|i_{r_n}\>)\cdot(\bigotimes_i(\<i_{r_{i1}}|\otimes\cdots \<i_{r_{im_i}}|)).$$

\begin{definition}[Semantics of expressions]
The interpretation of $e$ under valuation $v$, written as $\sem{e}_v$, is defined by the clauses of 
{\allowdisplaybreaks
 \begin{align*}
    & \text{(Scalars)} && 
 \sem{0} \equiv 0, 
 \qquad 
 \sem{1} \equiv 1,
 \qquad
 \sem{a + b} \equiv \sem{a} + \sem{b},
 \qquad
 \sem{a \times b} \equiv \sem{a} \times \sem{b}, 
    \\ & &&
 \sem{a^*} \equiv \sem{a}^*,
 \qquad
 \sem{\delta_{s, t}} \equiv \left\{
 \begin{array}{ll}
        1, & \text{where } \sem{s} = \sem{t}, \\
        0, & \text{where } \sem{s} \neq \sem{t}, 
 \end{array}
 \right.
 \qquad
 \sem{B \cdot K} \equiv \sem{B} \cdot \sem{K},
  \\[0.2cm]
    & \text{(Constants)} &&
 \sem{\mathbf{0}_\mathcal{K}(\sigma)} \equiv \mathbf{0}, 
 \qquad
 \sem{\mathbf{0}_\mathcal{B}(\sigma)} \equiv \mathbf{0},
 \qquad
 \sem{\mathbf{0}_\mathcal{O}(\sigma, \tau)} \equiv \mathbf{0}, 
 \qquad
 \sem{\mathbf{1}_\mathcal{O}(\sigma)} \equiv \mathbf{I},
  \\[0.2cm]
    & \text{(Basis)} &&
 \sem{\ket{t}} \equiv \ket{\sem{t}},
 \qquad
 \sem{\bra{t}} \equiv \bra{\sem{t}},
  \\[0.2cm]
    & \text{(Shared symbols)} &&
 \sem{D^\dagger} \equiv \sem{D}^\dagger,
 \qquad
 \sem{a.D} \equiv \sem{a} \sem{D},
 \qquad
 \sem{D_1 + D_2} \equiv \sem{D_1}+\sem{D_2}, \\
    & &&
 \sem{D_1 \cdot D_2} \equiv \sem{D_1} \cdot \sem{D_2},
 \qquad
 \sem{D_1 \otimes D_2} \equiv \sem{D_1} \otimes \sem{D_2}. \\[0.2cm]
       & \text{(set terms)} && 
    \sem{\mathbf{U}(\sigma)} \equiv \sem{\sigma},
    \qquad
    \sem{M_1 \times M_2} \equiv \sem{M_1} \times \sem{M_2},
    \\[0.2cm]
       & \text{(sum)} &&
    \llbracket \sum_{i \in M} X \rrbracket_v \equiv \sum_{m \in \sem{M}} \sem{X}_{v[i\mapsto m]} \\[0.2cm]
    & \text{(Labelled basis)} &&
      \sem{|i\>_r} = |\sem{i}\>,\qquad \sem{\<i|_r} = \<\sem{i}| \\[0.2cm]
    & \text{(Labelled lifting)} &&
    \sem{K_R} = \sem{\Swap_R} \cdot \sem{K}
 \qquad
 \sem{B_R} = \sem{B}\cdot \sem{\Swap_R} \\
 & && \sem{O_{R_1,R_2}} = \sem{\Swap_{R_1}}\cdot \sem{O}\cdot \sem{\Swap_{R_2}} \\[0.2cm]
 & \text{(Labelled tensor)} &&
 \sem{D_1\otimes \cdots \otimes D_n} = \sem{\Swap_{s_1,\cdot,s_n}}\cdot (\sem{D_1}\otimes \cdots \otimes \sem{D_1})\cdot \sem{\Swap_{s'_1,\cdot,s'_n}} \\[0.2cm]
 & \text{(Generalized dot)} &&
  \sem{D_1\cdot D_2} = \sem{\cl(D_1, s_2\backslash s'_1)}\cdot \sem{\cl(D_2, s'_1\backslash s_2)}
\end{align*}
}
where we assume $\Gamma\vdash D_i : \cD(s_i,s'_i)$.
\end{definition}
Denotational semantics of expressions. Symbol $D$ represents appropriate terms from the ket, bra, or operator sorts. States in $\mathcal{H}$ are represented by column vector, co-states in $\mathcal{H}^*$ by row vector, then all $\cdot$ above are interpreted as matrix multiplications, while $\otimes$ as Kronecker products.
We omit the semantics of functions.

\section{Axiomatic Semantics}
\label{sec: full axioms}
The full list of equational axioms are provided below.
{\allowdisplaybreaks
    \begin{align*}
        & \textsc{(Ax-Scalar)} &&
        (B \cdot K)^* = K^\dagger \cdot B^\dagger
        \\
            & \textsc{(Ax-Delta)} &&
        \delta_{s, t}^* = \delta_{s, t}
        \qquad
        \bra{s} \cdot \ket{t} = \delta_{s, t}
        \\ & &&
        \delta_{s, s} = 1
        \qquad
        s \neq t \vdash \delta_{s, t} = 0
        \qquad
        \delta_{s, t} = \delta_{t, s}
        \\
            & \textsc{(Ax-Linear)} &&
        \mathbf{0} + D = D
        \qquad
        D_1 + D_2 = D_2 + D_1
        \\ & &&
        (D_1 + D_2) + D_3 = D_1 + (D_2 + D_3)
        \\ & &&
        0.D = \mathbf{0}
        \qquad
        a.\mathbf{0} = \mathbf{0}
        \qquad
        1.D = D
        \\ & &&
        a.(b.D) = (a \times b).D
        \qquad
        (a + b).D = a.D + b.D
        \\ & &&
        a.(D_1 + D_2) = a.D_1 + a.D_2
        \\
        & \textsc{(Ax-Bilinear)} &&
        D \cdot \mathbf{0} = \mathbf{0} 
        \qquad
        D_1 \cdot (a.D_2) = a.(D_1 \cdot D_2)
        \\ & &&
        D_0 \cdot (D_1 + D_2) = D_0 \cdot D_1 + D_0 \cdot D_2
        \\ & &&
        \mathbf{0} \cdot D = \mathbf{0}
        \qquad
        (a.D_1) \cdot D_2 = a.(D_1 \cdot D_2)
        \\ & &&
        (D_1 + D_2) \cdot D_0 = D_1 \cdot D_0 + D_2 \cdot D_0
        \\ 
        & &&
        D \otimes \mathbf{0} = \mathbf{0}
        \qquad
        D_1 \otimes (a.D_2) = a.(D_1 \otimes D_2)
        \\ & &&
        D_0 \otimes (D_1 + D_2) = D_0 \otimes D_1 + D_0 \otimes D_2
        \\ & &&
        \mathbf{0} \otimes D = \mathbf{0} 
        \qquad
        (a.D_1) \otimes D_2 = a.(D_1 \otimes D_2)
        \\ & &&
        (D_1 + D_2) \otimes D_0 = D_1 \otimes D_0 + D_2 \otimes D_0
        \\ 
            & \textsc{(Ax-Adjoint)} &&
        \mathbf{0}^\dagger = \mathbf{0}
        \qquad
        (D^\dagger)^\dagger = D 
        \qquad
        (a.D)^\dagger = a^*.(D^\dagger)
        \\ & &&
        (D_1 + D_2)^\dagger = D_1^\dagger + D_2^\dagger
        \\
        & && (D_1 \cdot D_2)^\dagger = D_2^\dagger \cdot D_1^\dagger
        \qquad
        (D_1 \otimes D_2)^\dagger = D_1^\dagger \otimes D_2^\dagger
        \\
            & \textsc{(Ax-Comp)} &&
        D_0 \cdot (D_1 \cdot D_2) = (D_0 \cdot D_1) \cdot D_2
        \\ & &&
        (D_1 \otimes D_2) \cdot (D_3 \otimes D_4) = (D_1 \cdot D_3) \otimes (D_2 \cdot D_4)
        % \\ & &&
        % (K_1 \cdot B_1) \cdot (K_2 \cdot B_2) = (B_1 \cdot K_2) . (K_1 \otimes B_2)
        \\ & &&
        (K_1 \cdot B) \cdot K_2 = (B \cdot K_2).K_1
        \qquad
        B_1 \cdot (K \cdot B_2) = (B_1 \cdot K).B_2
        % \\ & &&
        % (K \cdot B) \cdot O = K \cdot (B \cdot O)
        % \qquad
        % O \cdot (K \cdot B) = (O \cdot  K) \cdot B
        % \\
        %     & &&
        % (K_1 \cdot B_1) \otimes (K_2 \cdot B_2) = (K_1 \otimes K_2) \cdot (B_1 \otimes B_2)
        \\ 
            & &&
        (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) = (B_1 \cdot K_1) \times (B_2 \cdot K_2)
        \\ 
            & \textsc{(Ax-Ground)} &&
        \mathbf{1}_\mathcal{O}^\dagger = \mathbf{1}_\mathcal{O}
        \qquad
        \textbf{1}_\mathcal{O} \cdot D = D 
        \qquad
        \mathbf{1}_\mathcal{O} \otimes \mathbf{1}_\mathcal{O} = \mathbf{1}_\mathcal{O} 
        \\ & &&
        \ket{t}^\dagger = \bra{t}
        \qquad
        \ket{s} \otimes \ket{t} =\ket{(s, t)} 
        \\
        & \textsc{(Sum)}
        && \sum_{i \in s} \mathbf{0} = \mathbf{0}
        \qquad 
        \sum_{i \in \mathbf{U}(\sigma)} \ket{i} \cdot \bra{i} = \mathbf{1}_\mathcal{O}(\sigma) \\
        & && i \text{ free in } t \Rightarrow \sum_{i \in \mathbf{U}(\sigma)} \delta_{i, t} = 1 \\
        & && i \text{ free in } t \Rightarrow \sum_{i \in \mathbf{U}(\sigma)} \delta_{i, t}.A = A\{i/t\} \\
        & && \sum_{i \in M} \sum_{j \in M} \delta_{i, j} = \sum_{j \in M} 1 \\
        & && \sum_{i \in M} \sum_{j \in M} \delta_{i, j}.A = \sum_{j \in M} A\{i/j\} \\
        & &&  b_1 \times \cdots \times (\sum_{i \in M} a) \times \cdots \times b_n 
        \reduce\ \sum_{i \in M} (b_1 \times \cdots \times a \times \cdots \times b_n) \\
        & && (\sum_{i \in M}a)^* = \sum_{i \in M} a^*
        \qquad
        (\sum_{i \in M} A)^\dagger = \sum_{i \in M} A^\dagger \\
        & &&
        a.(\sum_{i \in M} A) = \sum_{i \in M} a.A
        \qquad
        (\sum_{i \in M} a).A = \sum_{i \in M} a.A \\
        & &&
        X \cdot (\sum_{i \in M} Y) = \sum_{i \in M} X \cdot Y
        \qquad
        (\sum_{i \in M} X) \cdot Y = \sum_{i \in M} X \cdot Y \\
        & &&
        X \otimes (\sum_{i \in M} Y) = \sum_{i \in M} X \otimes Y
        \qquad
        (\sum_{i \in M} X) \otimes Y = \sum_{i \in M} X \otimes Y \\
        & && \sum_{i \in M}(a_1 + \cdots + a_n) = (\sum_{i \in M} a_1) + \cdots + (\sum_{i \in M} a_n) \\
        & && \sum_{i \in M}(X_1 + \cdots + X_n) =(\sum_{i \in M} X_1) + \cdots + (\sum_{i \in M} X_n) \\
        & && \sum_{i \in \mathbf{U}(\sigma \times \tau)} A =\sum_{j \in \mathbf{U}(\sigma)} \sum_{k \in \mathbf{U}(\tau)} A\{i/(j, k)\} \\
        & && \sum_{i \in M_1 \star M_2} A =\sum_{j \in M_1} \sum_{k \in M_2} A\{i/(j, k)\} \\
        & \textrm{($\alpha$-equivalence)}
        && \lambda x . A = \lambda y . A\{x/y\} \\
        & \textsc{(Sum-Swap)}
        && \sum_{i \in s_1} \sum_{j \in s_2} A = \sum_{j \in s_2} \sum_{i \in s_1} A
    \end{align*}
}



\section{Rewriting Rules}

\label{sec: rewriting rules}

This section includes all the rewriting rules used in the system. Related rules are collected in the same table. 

\renewcommand{\arraystretch}{1.2} % Increases row height by 50%

\begin{ruletable}{Reductions for the definitions and function applications.}
    %
    BETA-ARROW
    & $((\lambda x : T.t)\ u)\ \reduce\ t\{x/u\}$ \\
    %
    BETA-INDEX
    & $((\lambda x : T.t)\ u)\ \reduce\ t\{x/u\}$ \\
    %
    DELTA
    & $(c:=t:T) \in \Gamma \Rightarrow c\ \reduce\ t$
\end{ruletable}

\begin{ruletable}{The special to flatten all AC symbols within one call.}
    %
    R-FLATTEN
    & $a_1 + \cdots + (b_1 + \cdots + b_m) + \cdots + a_n$ \\
    & $\reduce\ a_1 + \cdots + b_1 + \cdots + b_m + \cdots + a_n$ \\ 
    \\
    & $a_1 \times \cdots \times (b_1 \times \cdots \times b_m) \times \cdots \times a_n$ \\
    & $\reduce\ a_1 \times \cdots \times b_1 \times \cdots \times b_m \times \cdots \times a_n$ \\
    \\
    & $X_1 + \cdots + (X_1' + \cdots + X_m') + \cdots + X_n$ \\
    & $\reduce\ X_1 + \cdots + X_1' + \cdots + X_m' + \cdots + X_n$
\end{ruletable}

\begin{ruletable}{Rules for scalar symbols.}
    %
    R-CONJ5
    & $ \delta_{s, t}^* \ \reduce\ \delta_{s, t}$ \\
    %
    R-CONJ6
    & $ (B \cdot K)^* \ \reduce\ K^\dagger \cdot B^\dagger $ \\
    %
    R-DOT0
    & $ \ZEROB(\sigma) \cdot K \ \reduce\ 0 $ \\
    %
    R-DOT1
    & $ B \cdot \ZEROK(\sigma) \ \reduce\ 0 $ \\
    %
    R-DOT2
    & $ (a.B) \cdot K \ \reduce\ a \times (B \cdot K) $ \\
    %
    R-DOT3
    & $ B \cdot (a.K) \ \reduce\ a \times (B \cdot K) $ \\
    %
    R-DOT4
    & $ (B_1 + \cdots + B_n) \cdot K \ \reduce\ B_1 \cdot K + \cdots + B_n \cdot K $ \\
    %
    R-DOT5
    & $ B \cdot (K_1 + \cdots + K_n) \ \reduce\ B \cdot K_1 + \cdots + B \cdot K_n $ \\
    %
    R-DOT6
    & $ \bra{s} \cdot \ket{t} \ \reduce\ \delta_{s, t} $ \\
    %
    R-DOT7
    & $ (B_1 \otimes B_2) \cdot \ket{(s, t)} \ \reduce\ (B_1 \cdot \ket{s}) \times (B_2 \cdot \ket{t}) $ \\
    %
    R-DOT8
    & $ \bra{(s, t)} \cdot (K_1 \otimes K_2) \ \reduce\ (\bra{s} \cdot K_1) \times (\bra{t} \cdot K_2) $ \\
    %
    R-DOT9
    & $ (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) \ \reduce\ (B_1 \cdot K_1) \times (B_2 \cdot K_2) $ \\
    %
    R-DOT10
    & $ (B \cdot O) \cdot K \ \reduce\ B \cdot (O \cdot K) $ \\
    %
    R-DOT11
    & $ \bra{(s, t)} \cdot ((O_1 \otimes O_2) \cdot K) \ \reduce\ ((\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2)) \cdot K $ \\
    %
    R-DOT12
    & $ (B_1 \otimes B_2) \cdot ((O_1 \otimes O_2) \cdot K) \ \reduce\ ((B_1 \cdot O_1) \otimes (B_2 \cdot O_2)) \cdot K $ \\
    %
    R-DELTA0
    & $ \delta_{a, a} \ \reduce\ 1$ \\
    %
    R-DELTA1
    & $ \delta_{(a, b), (c, d)} \ \reduce\ \delta_{a, c} \times \delta_{b, d}$ \\
\end{ruletable}


\begin{ruletable}{Rules for scaling.}
    %
    R-SCR0
    & $ 1.X \ \reduce\ X $ \\
    %
    R-SCR1
    & $ a.(b.X) \ \reduce\ (a \times b).X $ \\
    %
    R-SCR2
    & $ a.(X_1 + \cdots + X_n) \ \reduce\ a.X_1 + \cdots + a.X_n $ \\
    %
    R-SCRK0
    & $ K : \KType(\sigma) \Rightarrow 0.K \ \reduce\ \ZEROK(\sigma)$ \\
    %
    R-SCRK1
    & $ a.\ZEROK(\sigma) \ \reduce\ \ZEROK(\sigma) $ \\
    % 
    R-SCRB0
    & $ B : \BType(\sigma) \Rightarrow 0.B \ \reduce\ \ZEROB(\sigma)$ \\
    % 
    R-SCRB1
    & $ a.\ZEROB(\sigma) \ \reduce\ \ZEROB(\sigma) $ \\
    % 
    R-SCRO0
    & $ O : \OType(\sigma, \tau) \Rightarrow 0.O \ \reduce\ \ZEROO(\sigma, \tau)$ \\
    % 
    R-SCRO1
    & $ a.\ZEROO(\sigma, \tau) \ \reduce\ \ZEROO(\sigma, \tau) $ \\
\end{ruletable}

\begin{ruletable}{Rules for addition. }
    %
    R-ADDID
    & $+(X) \ \reduce\ X$ \\
    %
    R-ADD0
    & $Y_1 + \cdots + X + \cdots + X + \cdots + Y_n \ \reduce\ Y_1 + \cdots + Y_n + \cdots + (1+1).X$ \\
    %
    R-ADD1
    & $Y_1 + \cdots + X + \cdots + a.X + \cdots + Y_n \ \reduce\ Y_1 + \cdots + Y_n + (1+a).X$ \\
    %
    R-ADD2
    & $Y_1 + \cdots + a.X + \cdots + X + \cdots + Y_n \ \reduce\ Y_1 + \cdots + Y_n + (a+1).X$ \\
    %
    R-ADD3
    & $Y_1 + \cdots + a.X + \cdots + b.X + \cdots + Y_n \ \reduce\ Y_1 + \cdots + Y_n + (a+b).X$ \\
    %
    R-ADDK0
    & $K_1 + \cdots + \ZEROK(\sigma) + \cdots + K_n\ \reduce K_1 + \cdots + K_n$ \\
    %
    R-ADDB0
    & $B_1 + \cdots + \ZEROB(\sigma) + \cdots + B_n \ \reduce\ B_1 + \cdots + B_n$ \\
    %
    R-ADDO0
    & $O_1 + \cdots + \ZEROO(\sigma, \tau) + \cdots + O_n \ \reduce\ O_1 + \cdots + O_n$ 
    \\
\end{ruletable}

\begin{ruletable}{Rules for adjoint.}
    %
    R-ADJ0
    & $ (X^\dagger)^\dagger \ \reduce\ X $ \\
    %
    R-ADJ1
    & $ (a.X)^\dagger \ \reduce\ (a^*).(X^\dagger) $ \\
    %
    R-ADJ2
    & $ (X_1 + \cdots + X_n)^\dagger \ \reduce\ X_1^\dagger + \cdots + X_n^\dagger $ \\
    %
    R-ADJ3
    & $ (X \otimes Y)^\dagger \ \reduce\ X^\dagger \otimes Y^\dagger$ \\
    %
    R-ADJK0
    & $ \ZEROB(\sigma)^\dagger \ \reduce\ \ZEROK(\sigma) $ \\
    %
    R-ADJK1
    & $ \bra{t}^\dagger \ \reduce\ \ket{t} $ \\
    %
    R-ADJK2
    & $ (B \cdot O)^\dagger\ \reduce\ O^\dagger \cdot B^\dagger $ \\
    %
    R-ADJB0
    & $ \ZEROK(\sigma)^\dagger \ \reduce\ \ZEROB(\sigma) $ \\
    %
    R-ADJB1
    & $ \ket{t}^\dagger \ \reduce\ \bra{t} $ \\
    %
    R-ADJB2
    & $ (O \cdot K)^\dagger\ \reduce\ K^\dagger \cdot O^\dagger $ \\
    %
    R-ADJO0
    & $ \ZEROO(\sigma, \tau)^\dagger \ \reduce\ \ZEROO(\tau, \sigma) $ \\
    %
    R-ADJO1
    & $ \ONEO(\sigma)^\dagger \ \reduce\ \ONEO(\sigma)$ \\
    %
    R-ADJO2
    & $ (K \cdot B)^\dagger \ \reduce\ B^\dagger \cdot K^\dagger$ \\
    %
    R-ADJO3
    & $ (O_1 \cdot O_2)^\dagger \ \reduce\ O_2^\dagger \cdot O_1^\dagger $ \\
\end{ruletable}

\begin{ruletable}{Rules for tensor product.}
    R-TSR0
    & $ (a.X_1) \otimes X_2 \ \reduce\ a.(X_1 \otimes X_2) $ \\
    %
    R-TSR1
    & $ X_1 \otimes (a.X_2) \ \reduce\ a.(X_1 \otimes X_2) $ \\
    %
    R-TSR2
    & $ (X_1 + \cdots + X_n) \otimes X' \reduce X_1 \otimes X' + \cdots + X_n \otimes X' $ \\
    %
    R-TSR3
    & $ X' \otimes (X_1 + \cdots + X_n) \reduce X' \otimes X_1 + \cdots + X' \otimes X_n $ \\
    %
    R-TSRK0
    & $ K : \KType(\tau) \Rightarrow \ZEROK(\sigma) \otimes K\ \reduce\ \ZEROK(\sigma \times \tau) $ \\
    %
    R-TSRK1
    & $ K : \KType(\tau) \Rightarrow K \otimes \ZEROK(\sigma)\ \reduce\ \ZEROK(\tau \times \sigma) $ \\
    %
    R-TSRK2
    & $\ket{s} \otimes \ket{t} \ \reduce\ \ket{(s, t)}$ \\
    %
    R-TSRB0
    & $ B : \BType(\tau) \Rightarrow \ZEROB(\sigma) \otimes B\ \reduce\ \ZEROB(\sigma \times \tau) $ \\
    %
    R-TSRB1
    & $ B : \BType(\tau) \Rightarrow B \otimes \ZEROB(\sigma)\ \reduce\ \ZEROB(\tau \times \sigma) $ \\
    %
    R-TSRB2
    & $\bra{s} \otimes \bra{t} \ \reduce\ \bra{(s, t)}$ \\
    %
    R-TSRO0
    & $ O : \OType(\sigma, \tau) \Rightarrow O \otimes \ZEROO(\sigma', \tau') \ \reduce\ \ZEROO(\sigma \times \sigma', \tau \times \tau') $ \\
    % 
    R-TSRO1
    & $ O : \OType(\sigma, \tau) \Rightarrow \ZEROO(\sigma', \tau') \otimes O \ \reduce\ \ZEROO(\sigma' \times \sigma, \tau' \times \tau) $ \\
    %
    R-TSRO2
    & $\ONEO(\sigma) \otimes \ONEO(\tau)\ \reduce\ \ONEO(\sigma \times \tau)$ \\
    %
    R-TSRO3
    & $ (K_1 \cdot B_1) \otimes (K_2 \cdot B_2)\ \reduce\ (K_1 \otimes K_2) \cdot (B_1 \otimes B_2) $ \\
    %
\end{ruletable}

\begin{ruletable}{Rule for $O\cdot K$.}
    %
    R-MULK0
    & $ \ZEROO(\sigma, \tau) \cdot K \ \reduce\ \ZEROK(\sigma) $ \\
    %
    R-MULK1
    & $ O : \OType(\sigma, \tau) \Rightarrow O \cdot \ZEROK(\tau) \ \reduce\ \ZEROK(\sigma) $ \\
    %
    R-MULK2
    & $ \ONEO(\sigma) \cdot K \ \reduce K $ \\
    %
    R-MULK3
    & $ (a.O) \cdot K \ \reduce\ a.(O \cdot K) $ \\
    %
    R-MULK4
    & $ O \cdot (a.K) \ \reduce\ a.(O \cdot K) $ \\
    %
    R-MULK5
    & $ (O_1 + \cdots + O_n) \cdot K \ \reduce\ O_1 \cdot K + \cdots + O_n \cdot K $ \\
    %
    R-MULK6
    & $ O \cdot (K_1 + \cdots + K_n) \ \reduce\ O \cdot K_1 + \cdots + O \cdot K_n $ \\
    %
    R-MULK7
    & $ (K_1 \cdot B) \cdot K_2 \ \reduce\ (B \cdot K_2).K_1 $ \\
    %
    R-MULK8
    & $ (O_1 \cdot O_2) \cdot K \ \reduce\ O_1 \cdot (O_2 \cdot K) $ \\
    %
    R-MULK9
    & $ (O_1 \otimes O_2) \cdot ((O_1' \otimes O_2') \cdot K)\ \reduce\ ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2')) \cdot K $ \\
    %
    R-MULK10
    & $ (O_1 \otimes O_2) \cdot \ket{(s, t)}\ \reduce\ (O_1 \cdot \ket{s}) \otimes (O_2 \cdot \ket{t}) $ \\
    %
    R-MULK11
    & $ (O_1 \otimes O_2) \cdot (K_1 \otimes K_2)\ \reduce\ (O_1 \cdot K_1) \otimes (O_2 \cdot K_2) $
\end{ruletable}


\begin{ruletable}{Rule for $B\cdot O$.}
    %
    R-MULB0
    & $ B \cdot \ZEROO(\sigma, \tau) \ \reduce\ \ZEROB(\tau) $ \\
    %
    R-MULB1
    & $ O : \OType(\sigma, \tau) \Rightarrow \ZEROB(\sigma) \cdot O\ \reduce\ \ZEROB(\tau) $ \\
    %
    R-MULB2
    & $ B \cdot \ONEO(\sigma) \ \reduce B $ \\
    %
    R-MULB3
    & $ (a.B) \cdot O \ \reduce\ a.(B \cdot O) $ \\
    %
    R-MULB4
    & $ B \cdot (a.O) \ \reduce\ a.(B \cdot O) $ \\
    %
    R-MULB5
    & $ (B_1 + \cdots + B_n) \cdot O \ \reduce\ B_1 \cdot O + \cdots + B_n \cdot O $ \\
    %
    R-MULB6
    & $ B \cdot (O_1 + \cdots + O_n) \ \reduce\ B \cdot O_1 + \cdots + B \cdot O_n $ \\
    %
    R-MULB7
    & $ B_1 \cdot (K \cdot B_2) \ \reduce\ (B_1 \cdot K).B_2 $ \\
    %
    R-MULB8
    & $ B \cdot (O_1 \cdot O_2) \ \reduce\ (B \cdot O_1) \cdot O_2 $ \\
    %
    R-MULB9
    & $ (B \cdot (O_1' \otimes O_2')) \cdot (O_1 \otimes O_2) \ \reduce\ B \cdot ((O_1' \otimes O_2') \cdot (O_1 \otimes O_2)) $ \\
    %
    R-MULB10
    & $ \bra{(s, t)} \cdot (O_1 \otimes O_2)\ \reduce\ (\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2) $ \\
    %
    R-MULB11
    & $ (B_1 \otimes B_2) \cdot (O_1 \otimes O_2)\ \reduce\ (B_1 \cdot O_1) \otimes (B_2 \cdot O_2) $
\end{ruletable}

\begin{ruletable}{Rules for $K \cdot B$.}
    %
    R-OUTER0
    & $ B : \BType(\tau) \Rightarrow \mathbf{0}_\mathcal{K}(\sigma) \cdot B\ \reduce\ \mathbf{0}_\mathcal{O}(\sigma, \tau) $ \\
    %
    R-OUTER1
    & $ K : \KType(\sigma) \Rightarrow K \cdot \mathbf{0}_\mathcal{B}(\tau)\ \reduce\ \mathbf{0}_\mathcal{O}(\sigma, \tau) $ \\
    %
    R-OUTER2
    & $ (a.K) \cdot B\ \reduce\ a.(K \cdot B) $ \\
    %
    R-OUTER3
    & $ K \cdot (a.B)\ \reduce\ a.(K \cdot B) $ \\
    %
    R-OUTER4
    & $ (K_1 + \cdots + K_n) \cdot B\ \reduce\ K_1 \cdot B + \cdots + K_n \cdot B $ \\
    %
    R-OUTER5
    & $ K \cdot (B_1 + \cdots + B_n)\ \reduce\ K \cdot B_1 + \cdots + K \cdot B_n $ \\
\end{ruletable}

\begin{ruletable}{Rules for $O_1 \cdot O_2$.}
    %
    R-MULO0
    & $ O : \OType(\tau, \rho) \Rightarrow \ZEROO(\sigma, \tau) \cdot O\ \reduce\ \ZEROO(\sigma, \rho) $ \\
    %
    R-MULO1
    & $ O : \OType(\sigma, \tau) \Rightarrow O \cdot \ZEROO(\tau, \rho)\ \reduce\ \mathbf{0}_\mathcal{O}(\sigma, \rho) $ \\
    %
    R-MULO2
    & $ \ONEO(\sigma) \cdot O \ \reduce\ O $ \\
    %
    R-MULO3
    & $ O \cdot \ONEO(\sigma) \ \reduce\ O $ \\
    %
    R-MULO4
    & $ (K \cdot B) \cdot O \ \reduce\ K \cdot (B \cdot O) $ \\
    %
    R-MULO5
    & $ O \cdot (K \cdot B) \ \reduce\ (O \cdot K) \cdot B $ \\
    %
    R-MULO6
    & $ (a.O_1) \cdot O_2 \ \reduce\ a.(O_1 \cdot O_2) $ \\
    %
    R-MULO7
    & $ O_1 \cdot (a.O_2) \ \reduce\ a.(O_1 \cdot O_2) $ \\
    %
    R-MULO8
    & $ (O_1 + \cdots + O_n) \cdot O'\ \reduce\ O_1 \cdot O' + \cdots + O_n \cdot O' $ \\
    %
    R-MULO9
    & $ O' \cdot (O_1 + \cdots + O_n)\ \reduce\ O' \cdot O_1 + \cdots + O' \cdot O_n $ \\
    %
    R-MULO10
    & $ (O_1 \cdot O_2) \cdot O_3\ \reduce\ O_1 \cdot (O_2 \cdot O_3) $ \\
    %
    R-MULO11
    & $ (O_1 \otimes O_2) \cdot (O_1' \otimes O_2')\ \reduce\ (O_1 \cdot O_1') \otimes (O_2 \cdot O_2') $ \\
    %
    R-MULO12
    & $ (O_1 \otimes O_2) \cdot ((O_1' \otimes O_2') \cdot O_3)\ \reduce\ ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2')) \cdot O_3 $ \\  
\end{ruletable}

\begin{ruletable}{Rules for sets.}
    %
    R-SET0
    & $ \mathbf{U}(\sigma) \star \mathbf{U}(\tau) \ \reduce\ \mathbf{U}(\sigma \times \tau) $
\end{ruletable}

\begin{ruletable}{Rules for sum operators.}
    %
    R-SUM-CONST0
    & $ \sum_{x \in s} 0 \ \reduce\ 0 $ \\
    %
    R-SUM-CONST1
    & $ \sum_{x \in s} \ZEROK(\sigma)\ \reduce\ \ZEROK(\sigma) $ \\
    %
    R-SUM-CONST2
    & $ \sum_{x \in s} \ZEROB(\sigma)\ \reduce\ \ZEROB(\sigma) $ \\
    %
    R-SUM-CONST3
    & $ \sum_{x \in s} \ZEROO(\sigma, \tau)\ \reduce\ \ZEROO(\sigma, \tau) $ \\
    %
    R-SUM-CONST4
    & $ \ONEO(\sigma) \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)} \ket{i} \cdot \bra{i} $
\end{ruletable}

\begin{ruletable}{Rules for eliminating $\delta_{s, t}$. These rules match the $\delta$ operator modulo the commutativity of its arguments.}
    %
    R-SUM-ELIM0
    & $ i \text{ free in } t \Rightarrow \sum_{i \in \mathbf{U}(\sigma)} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} \delta_{i, t}$ \\
    & $ \reduce\ \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n}  1$ \\
    \\
    %
    R-SUM-ELIM1
    & $ i \text{ free in } t \Rightarrow $ \\
    & $ \sum_{i \in \mathbf{U}(\sigma)} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (a_1 \times \cdots \times \delta_{i, t} \times \cdots \times a_n) $ \\
    & $ \reduce\ \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} a_1\{i/t\} \times \cdots \times a_n\{i/t\} $ \\
    \\
    %
    R-SUM-ELIM2
    & $ i \text{ free in } t \Rightarrow \sum_{i \in \mathbf{U}(\sigma)} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (\delta_{i, t}.A) $ \\
    & $ \reduce\ \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} A\{i/t\} $ \\
    \\
    %
    R-SUM-ELIM3
    & $ i \text{ free in } t \Rightarrow $ \\
    & $ \sum_{i \in \mathbf{U}(\sigma)} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (a_1 \times \cdots \times \delta_{i, t} \times \cdots \times a_n).A $ \\
    & $ \reduce\ \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n}  (a_1\{i/t\} \times \cdots \times a_n\{i/t\}).A\{i/t\} $ \\
    \\
    %
    R-SUM-ELIM4
    & $ \sum_{i \in M} \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n}  \delta_{i, j}$ \\ 
    & $\reduce\ \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} 1 $ \\
    \\
    %
    R-SUM-ELIM5
    & $ \sum_{i \in M} \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (a_1 \times \dots \times \delta_{i, j} \times \cdots \times a_n) $ \\
    & $ \reduce\ \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (a_1\{j/i\} \times \cdots \times a_n\{j/i\}) $ \\
    \\
    %
    R-SUM-ELIM6
    & $ \sum_{i \in M} \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (\delta_{i, j}.A) $ \\
    & $ \reduce\ \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} A\{j/i\} $ \\
    \\
    %
    R-SUM-ELIM7
    & $ \sum_{i \in M} \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (a_1 \times \cdots \times \delta_{i, j} \times \cdots \times a_n).A $ \\
    & $ \reduce\ \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (a_1\{j/i\} \times \cdots \times a_n\{j/i\}).A\{j/i\} $ \\
    \\
    %
    R-SUM-ELIM8
    & $ \sum_{i \in M} \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} ((a_1 \times \cdots \times \delta_{i, j} \times \cdots \times a_n) + $ \\
    & $ \cdots + (b_1 \times \cdots \times \delta_{i, j} \times \cdots \times b_n)).A $ \\
    & $ \reduce\ \sum_{j \in M} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} ((a_1\{j/i\} \times \cdots \times a_n\{j/i\}) + $ \\
    & $ \cdots + (b_1\{j/i\} \times \cdots \times b_n\{j/i\})).A\{j/i\} $ \\
\end{ruletable}

\begin{ruletable}{Rules for pushing terms into sum operators. Because we apply type checking on variables, and stick to unique bound variables, these operations are always sound.}
    %
    R-SUM-PUSH0
    & $ b_1 \times \cdots \times (\sum_{i \in M} a) \times \cdots \times b_n$ \\
    & $\reduce\ \sum_{i \in M} (b_1 \times \cdots \times a \times \cdots \times b_n) $ \\
    %
    R-SUM-PUSH1
    & $ (\sum_{i \in M} a)^* \ \reduce\ \sum_{i \in M} a^* $ \\
    %
    R-SUM-PUSH2
    & $ (\sum_{i \in M} X)^\dagger \ \reduce\ \sum_{i \in M} X^\dagger $ \\
    %
    R-SUM-PUSH3
    & $ a.(\sum_{i \in M} X) \ \reduce\ \sum_{i \in M} (a.X) $ \\
    %
    R-SUM-PUSH4
    & $ (\sum_{i \in M} a).X \ \reduce\ \sum_{i \in M} (a.X) $ \\
    %
    R-SUM-PUSH5
    & $ (\sum_{i \in M} B)\cdot K \ \reduce\ \sum_{i \in M}(B \cdot K) $ \\
    %
    R-SUM-PUSH6
    & $ (\sum_{i \in M} O)\cdot K \ \reduce\ \sum_{i \in M}(O \cdot K) $ \\
    %
    R-SUM-PUSH7
    & $ (\sum_{i \in M} B)\cdot O \ \reduce\ \sum_{i \in M}(B \cdot O) $ \\
    %
    R-SUM-PUSH8
    & $ (\sum_{i \in M} K)\cdot B \ \reduce\ \sum_{i \in M}(K \cdot B) $ \\
    %
    R-SUM-PUSH9
    & $ (\sum_{i \in M} O_1)\cdot O_2 \ \reduce\ \sum_{i \in M}(O_1 \cdot O_2) $ \\
    %
    R-SUM-PUSH10
    & $ B \cdot (\sum_{i \in M} K) \ \reduce\ \sum_{i \in M}(B \cdot K) $ \\
    %
    R-SUM-PUSH11
    & $ O \cdot (\sum_{i \in M} K) \ \reduce\ \sum_{i \in M}(O \cdot K) $ \\
    %
    R-SUM-PUSH12
    & $ B \cdot (\sum_{i \in M} O) \ \reduce\ \sum_{i \in M}(B \cdot O) $ \\
    %
    R-SUM-PUSH13
    & $ K \cdot (\sum_{i \in M} B) \ \reduce\ \sum_{i \in M}(K \cdot B) $ \\
    %
    R-SUM-PUSH14
    & $ O_1 \cdot (\sum_{i \in M} O_2) \ \reduce\ \sum_{i \in M}(O_1 \cdot O_2) $ \\
    %
    R-SUM-PUSH15
    & $ (\sum_{i \in M} X_1) \otimes X_2 \ \reduce\ \sum_{i \in M} (X_1 \otimes X_2) $ \\
    %
    R-SUM-PUSH16
    & $ X_1 \otimes (\sum_{i \in M} X_2) \ \reduce\ \sum_{i \in M} (X_1 \otimes X_2) $
\end{ruletable}


\begin{ruletable}{Rules for addition and index in sum.}
    %
    R-SUM-ADDS0
    & $\sum_{i \in M}(a_1 + \cdots + a_n) \ \reduce\ (\sum_{i \in M} a_1) + \cdots + (\sum_{i \in M} a_n) $ \\
    % %
    % R-SUM-ADDS1
    % & $\sum_{i \in M}(b_1 \times \cdots \times (a_1 + \cdots + a_n) \times \cdots \times b_m) $ \\
    % & $ \reduce\ (\sum_{i \in M} (b_1 \times \cdots \times a_1 \times \cdots \times b_m) + \cdots + (\sum_{i \in M} (b_1 \times \cdots \times a_n \times \cdots \times b_m)) $ \\
    %
    R-SUM-ADD0
    & $\sum_{i \in M}(X_1 + \cdots + X_n) \ \reduce\ (\sum_{i \in M} X_1) + \cdots + (\sum_{i \in M} X_n) $ \\
    %
    R-SUM-INDEX0
    & $ \sum_{i \in \mathbf{U}(\sigma \times \tau)} A \ \reduce\ \sum_{j \in \mathbf{U}(\sigma)} \sum_{k \in \mathbf{U}(\tau)} A\{i/(j, k)\} $ \\
    %
    R-SUM-INDEX1
    & $ \sum_{i \in M_1 \star M_2} A \ \reduce\ \sum_{j \in M_1} \sum_{k \in M_2} A\{i/(j, k)\} $
\end{ruletable}


\begin{ruletable}{Rules for bool index.}
    %
    R-BIT-DELTA
    & $\delta_{0, 1} \ \reduce\ 0$ \\
    %
    R-BIT-ONEO
    & $\ONEO(\textsf{bool})\ \reduce\ \ket{0}\bra{0} + \ket{1}\bra{1} $ \\
    %
    R-BIT-SUM
    & $\sum_{i \in \mathbf{U}(\textsf{bool})} A\ \reduce\ A\{i/0\} + A\{i/1\}$
\end{ruletable}

\begin{ruletable}{Rules about addition and sum.}
    R-MULS2
    & $b_1 \times \cdots \times (a_1 + \cdots + a_n) \times \cdots \times b_m$ \\
    & $\reduce\ (b_1 \times \cdots \times a_1 \times \cdots \times b_m) + \cdots + (b_1 \times \cdots \times a_n \times \cdots \times b_m)$ \\
    \\
    %
    R-SUM-ADD1
    & $ Y_1 + \cdots + Y_n + \sum_{i \in M}(a+b).X$ \\
    & $ \reduce\ Y_1 + \cdots + \sum_{i \in M}(a.X) + \cdots + \sum_{i \in M}(b.X) + Y_n$ \\
    \\
    %
    R-SUM-FACTOR
    & $X_1 + \cdots + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}A) $ \\
    & $ + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}A) + \cdots +X_n$ \\
    & $X_1 + \cdots + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}(1+1).A) + \cdots +X_n$ \\
    \\
    & $X_1 + \cdots + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}a.A) $ \\
    & $ + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}A) + \cdots +X_n$ \\
    & $X_1 + \cdots + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}(a+1).A) + \cdots +X_n$ \\
    \\
    & $X_1 + \cdots + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}a.A) $ \\
    & $ + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}b.A) + \cdots +X_n$ \\
    & $X_1 + \cdots + (\sum_{k_1 \in s_1}\cdots\sum_{k_n \in s_n}(a+b).A) + \cdots +X_n$ \\
\end{ruletable}

\begin{ruletable}{Rules to eliminate labels in Dirac notation.}
    %
    R-L-EXPAND
    & $K_R \ \reduce\ \sum_{i_{r_1}\in\bU(\sigma_{r_1})}\cdots \sum_{i_{r_n}\in\bU(\sigma_{r_n})} (\<i_R|\cdot K). (|i_{r_1}\>_{r_i}\otimes\cdots\otimes|i_{r_n}\>_{r_n})$ \\
    \\
    %
    & $B_R \ \reduce\ \sum_{i_{r_1}\in\bU(\sigma_{r_1})}\cdots \sum_{i_{r_n}\in\bU(\sigma_{r_n})} (B\cdot |i_R\>). ({}_{r_1}\<i_{r_1}|\otimes\cdots\otimes{}_{r_n}\<i_{r_n}|)$\\
    \\
    %
    & $O_{R,R'} \ \reduce\ \sum_{i_{r_1}\in\bU(\sigma_{r_1})}\cdots \sum_{i_{r_n}\in\bU(\sigma_{r_n})}
    \sum_{i_{r'_1}\in\bU(\sigma_{r'_1})}\cdots \sum_{i_{r'_{n'}}\in\bU(\sigma_{r'_{n'}})}$ \\
    & $(\<i_R|\cdot O\cdot |i_{R'}\>).(|i_{r_1}\>_{r_i}\otimes\cdots\otimes|i_{r_n}\>_{r_n} \otimes {}_{r'_1}\<i_{r'_1}|\otimes\cdots\otimes{}_{r'_{n'}}\<i_{r'_{n'}}|)$
\end{ruletable}



\begin{ruletable}{Rules for labelled Dirac notation.}
    %
    R-ADJDK
    & $ ({}_r\<i|)^\dagger \ \reduce\ |i\>_r$ \\
    %
    R-ADJDB
    & $ (|i\>_r)^\dagger \ \reduce\ {}_r\<i|$ \\
    R-ADJD0
    & $ (D_1 \otimes \cdots \otimes D_n)^\dagger \ \reduce\ D_1^\dagger \otimes \cdots \otimes D_n^\dagger$ \\
    %
    R-ADJD1
    & $ (D_1\cdot D_2)^\dagger \ \reduce\ D_2^\dagger \cdot D_1^\dagger$ \\
    %
    R-SCRD0
    & $ D_1 \otimes \cdots \otimes (a.D_n) \otimes \cdots \otimes D_m \ \reduce\ a.(D_1 \otimes \cdots \otimes D_m) $ \\
    %
    R-SCRD1
    & $ (a.D_1) \cdot D_2 \ \reduce\ a.(D_1 \cdot D_2) $ \\
    %
    R-SCRD2
    & $ D_1 \cdot (a.D_2) \ \reduce\ a.(D_1 \cdot D_2) $ \\
    %
    R-TSRD0
    & $ X_1 \otimes \cdots \otimes (D_1 + \cdots + D_n) \otimes \cdots X_m$ \\
    & $ \reduce\ X_1 \otimes \cdots D_1 \cdots \otimes X_m + \cdots + X_1 \otimes \cdots D_n  \cdots \otimes X_m $ \\
    %
    R-DOTD0
    & $ (D_1 + \cdots + D_n) \cdot D\ \reduce\ D_1 \cdot D + \cdots + D_n \cdot D $ \\
    %
    R-DOTD1
    & $ D \cdot (D_1 + \cdots + D_n)\ \reduce\ D \cdot D_1 + \cdots + D \cdot D_n $ \\
    %
    R-SUM-PUSHD0
    & $ X_1 \otimes \cdots (\sum_{i \in M} D) \cdots \otimes X_2\ \reduce\ \sum_{i \in M} (X_1 \otimes \cdots D \cdots \otimes X_n) $ \\
    %
    R-SUM-PUSHD1
    & $ (\sum_{i \in M} D_1) \cdot D_2 \ \reduce\ \sum_{i \in M} (D_1 \cdot D_2) $ \\
    %
    R-SUM-PUSHD2
    & $ D_1 \cdot (\sum_{i \in M} D_2) \ \reduce\ \sum_{i \in M} (D_1 \cdot D_2) $
\end{ruletable}

\begin{ruletable} {Rules to simplify dot product in labelled Dirac notation.}
    %
    R-L-SORT0
    & $ A : \DType(s_1, s_2), B : \DType(s_1', s_2'), s_2 \cap s_1'=\emptyset \Rightarrow A \cdot B \ \reduce\ A \otimes B $ \\
    %
    R-L-SORT1
    & ${}_r\bra{i}\cdot\ket{j}_r \ \reduce\ \delta_{i, j}$ \\
    %
    R-L-SORT2
    & ${}_r\bra{i}\cdot(Y_1 \otimes \cdots \otimes \ket{j}_r \otimes \cdots \otimes Y_m) \ \reduce\ \delta_{i, j}.(Y_1  \otimes \cdots \otimes Y_m)$ \\
    %
    R-L-SORT3
    & $(X_1 \otimes \cdots \otimes {}_r\bra{i} \otimes \cdots \otimes X_n) \cdot \ket{j}_r \ \reduce\ \delta_{i,j}.(X_1 \otimes \cdots \otimes X_n)$ \\
    %
    R-L-SORT1
    & $ (X_1 \otimes \cdots \otimes {}_r\bra{i} \otimes \cdots \otimes X_n) \cdot (Y_1 \otimes \cdots \otimes \ket{j}_r \otimes \cdots \otimes Y_m) $ \\
    & $\reduce\ \delta_{i,j}.(X_1 \otimes \cdots \otimes X_n) \cdot (Y_1 \otimes \cdots \otimes Y_m)$
\end{ruletable}

\subsection{Proof of Theorem \ref{thm: normalization}}
As Lemma \ref{lem: axiom sound} holds for all rewriting rules, it is then sufficient to check: 1. the termination of normalization step; 2. the normalization step will not get stuck; and 3. the final step that discard variables is sound and complete, i.e., deciding labelled Dirac equality with subterms in form Eqn. (\ref{eqn:Labelled normal1}) is equivalent to deciding plain Dirac equality with subterms in Eqn. (\ref{eqn:Labelled normal1}). 1 and 2 ensures that the normalization procedure always provides $e_1 = e_2$.
\begin{enumerate}
  \item By checking there is no circular rules, and ordering in step 3 always terminates.
  \item We can show that if the equality is not in form (\ref{eqn:Labelled normal}), there must exists one of the rules can be further applied. Besids, ordering is always applicable.
  \item Since all tensors in Eqn. (\ref{eqn:Labelled normal1}) are ordered, so the denotational semantics of LHS and RHS of Eqn. (\ref{eqn:Labelled normal1}) are exactly the semantics of LHS and RHS of Eqn. (\ref{eqn:Labelled normal2}).
\end{enumerate}
% \begin{proof}
%   Notice that all rewriting rules and ordering perserve the types, so the final step eliminating labels is both sound and complete. 
%   It is routinely to check that each rewriting rules and ordering step are sound based on the semantics. This directly leads to the soundness. For completeness, we need further check if the normalization procedure always provide $e_1 = e_2$, i.e., it never gets stuck and terminates. Step 1 is trivial. For step 2, it can be further checked that 1. there is no circular rules and thus terminates, and 2. if it is not in form (\ref{eqn:Labelled normal}), there must exists one of the rules can be further applied. For step 3, ordering is always applicable. This completes the proof.
% \end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Efficient Algorithm for Deciding the equivalence}
\label{sec: decide}
% The equivalence of Dirac notations are decided by normalization, which transforms equivalent expressions under a set of axioms into the same syntax. For the entire axiom set $R \cup E$ of Dirac notation, the previous algorithm conducts normalization partially on $R$ by term rewriting modulo $E$, and axioms in $E$ are checked by iterating through all permutations. This direct solution has factorial compleixty on maximum number of AC symbol arguemnts, and is observed to be critical to the low efficiency. Here we propose an efficient algorithm to perform total nomralization on $R \cup E$, and their comparison are illustrated below.
% \[
% \text{(partial)}\qquad e_1 \mathop{\twoheadrightarrow}^R e_1' \mathop{=}^E e_2' \mathop{\twoheadleftarrow}^R e_2
% \qquad
% \text{(total)}\qquad e_1 \mathop{\twoheadrightarrow}^{R \cup E} e \equiv e \mathop{\twoheadleftarrow}^{R \cup E} e_2
% \]

% The problem is that, the axiom set $\Gamma$ in~\Cref{def: axiom \Gamma} cannot be decided through term rewriting. A direct solution is to decide \( \Gamma \) by examining all possible permutations in the rewriting result, which has high complexity. 
% In this work, we introduce a more efficient approach by incorporating sorting algorithms into the normalization procedure. 

% The normalization procedure consists of the following steps. Steps 1 - 3 are term rewriting steps for $R$, and steps 4 - 6 are our algorithm to further normalize the axiom set $E$.
% \begin{enumerate}
%     \item \textbf{First Rewritings}: Expand definitions and simplify expressions.
%     \item \textbf{Variable Expansion}: Convert to scalar expressions for better decidability.
%     \item \textbf{Second Rewritings}: Normalize terms on \( R \) modulo \( E \).
%     \item \textbf{Sorting Without Bound Variables}: Normalize AC-equivalence.
%     \item \textbf{Swap Successive Summations}: Normalize SUM-SWAP equivalences.
%     \item \textbf{De Bruijn Normalization}: Normalize \( \alpha \)-equivalence.
% \end{enumerate}


% Term rewriting rules, represented as \( l \ \reduce\ r \), are applied recursively to normalize terms. In each step, subterms matching the left-hand side \( l \) of a rule are replaced with the corresponding right-hand side \( r \). The procedure terminates when no further rewritings can be made.
% A comprehensive list of rewriting rules can be found in~\Cref{sec: rewriting rules}. Below are some key examples to illustrate the design:

% One of our optimizations is using functions with indefinite arities. 
% Therefore, we use a flattening rule to handle associativity with AC symbols:
% \[
% a_1 + \cdots + (b_1 + \cdots + b_m) + \cdots + a_n \ \reduce\ a_1 + \cdots + b_1 + \cdots + b_m + \cdots + a_n.
% \]
% Commutativity is handled later in the sorting step. Many of the rewriting rules are directly derived from the equational axioms, such as:
% \begin{align*}
%     & \textrm{(R-DOT6)} && \bra{s} \cdot \ket{t} \ \reduce\  \delta_{s, t}, \\
%     & \textrm{(R-DELTA0)} && \delta_{s, s} \ \reduce\  1, \\
%     & \textrm{(R-MULK1)} && O : \OType(\sigma, \tau) \Rightarrow O \cdot \mathbf{0}_{\KType(\tau)} \ \reduce\  \mathbf{0}_{\KType(\sigma)}, \\
%     & \textrm{(R-MULK11)} && (O_1 \otimes O_2) \cdot (K_1 \otimes K_2) \ \reduce\  (O_1 \cdot K_1) \otimes (O_2 \cdot K_2).
% \end{align*}
% Some of these directions are obvious. For example, (R-DOT6) states that the inner product of two basis vectors is reduced to a delta expression, and (R-DELTA0) transforms a delta function on identical basis to a scalar \( 1 \). The rule (R-MULK1) reflects the axiom that multiplying a zero vector results in zero. This rule is conditional on typing, which is checked during rewriting. Some rules, like (R-MULK11), require a deeper understanding, such as the preference for tensor products over multiplication.

% As a reference, the term rewriting system in DiracDec has been proven complete for all axioms, except for the sum symbol. The completeness result is derived from checking the confluence and termination of the system. Our rewriting rules are translations from DiracDec into the typed and abstract language, ensuring that the corresponding symbols in our system are also complete.

% We also have additional rules that handle summations. For example:
% \begin{align*}
%     & \quad i \text{ free in } t \Rightarrow \sum_{i \in \mathbf{U}(\sigma)} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (\delta_{i, t}.A) \ \reduce\  \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} A\{i/t\}, \\
%     & \quad \left( \sum_{i \in M} B \right) \cdot K \ \reduce\  \sum_{i \in M} (B \cdot K).
% \end{align*}
% The first rule eliminates delta expressions in summations, while the second rule pushes summations outside of inner products. While there is no guarantee of completeness for these rules, they work effectively in practice.

% \subsubsection{Variable Expansion}
% One important technique, revealed in the DiracDec work, is the expansion of variables, which is critical for proofs involving summation. For example:
% \[
% \frac{\Gamma[\Gamma] \vdash K : \KType(\sigma)}{\Gamma[\Gamma] \vdash K \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(\bra{i} \cdot K).\ket{i}} \quad \quad
% \frac{\Gamma[\Gamma] \vdash B : \BType(\sigma)}{\Gamma[\Gamma] \vdash B \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(B \cdot \ket{i}).\bra{i}},
% \]
% \[
% \frac{\Gamma[\Gamma] \vdash O : \OType(\sigma, \tau)}{\Gamma[\Gamma] \vdash O \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)} \sum_{j \in \mathbf{U}(\tau)}(\bra{i} \cdot O \cdot \ket{j}).(\ket{i} \cdot \bra{j})}.
% \]
% These rules transform variables into their symbolic summations based on their decomposition over the basis. 
% The rules are not terminating, therefore is applied recrusively once in the second step called \textit{variable expansion}.
% Nevertheless, we have found that applying the expansion only once for all variables is sufficient for normalization.
% \begin{lemma}
%     Let \( \textrm{expand}(e) \) denote the result of expanding all variables in \( e \) once. For all well-typed terms \( e \) in \( \Gamma[\Gamma] \), \( \textrm{expand}(\textrm{expand}(e)) \) and \( \textrm{expand}(e) \) have the same normal form.
% \end{lemma}
% \begin{proof}
%     Expanding a ket variable twice, for example, results in the following transformation:
%     \[
%     \sum_{i \in \mathbf{U}(\sigma)} (\bra{i} \cdot \sum_{j \in \mathbf{U}(\sigma)} (\bra{j} \cdot K) \cdot \ket{j}) \cdot \ket{i} \ \reduce\  \sum_{i \in \mathbf{U}(\sigma)} \sum_{j \in \mathbf{U}(\sigma)} (\bra{j} \cdot K \cdot \braket{i|j}) \cdot \ket{i},
%     \]
%     where the delta symbol elimination rule returns the term to its original form. The same holds for bra and operator terms.
% \end{proof}



Now we analyse the axioms in $E$ to understand the difficulty and solution for normalization. 
For $\alpha$-equivalence, we want to rule out the influence of bound variable names. Therefore we use de Bruijn notation~\cite{deBruijn1972lambda}, which replaces the name with the distance from the lambda abstraction to the variable. For instance, the nominal lambda abstraction \( \lambda x. x \) is transformed into \( \lambda . \$0 \), while \( \lambda x. \lambda y. (x\ (y\ x)) \) is transformed into \( \lambda.\lambda. (\$1\ (\$0\ \$1)) \).

The remaining axioms, such as AC-equivalence and SUM-SWAP, assert equivalence under permutations. A standard approach for deciding such equivalences is to normalize terms by sorting in a predefined order. For example, given the dictionary order \( a < b < c \), the term \( b + c + a \) (and any other AC-equivalent term) is normalized into \( a + b + c \). However, in our setting, two intertwined difficulties arise: how to assign an order to all terms in the language, and how to simultaneously sort for both axioms.

Consider the following two equivalent terms:
\[
\sum_{i \in s_1} \sum_{j \in s_2} \bra{i} A \ket{j} \times \bra{j} B \ket{i}
= 
\sum_{i \in s_2} \sum_{j \in s_1} \bra{i} B \ket{j} \times \bra{j} A \ket{i}
\]
While these two terms are equivalent, directly sorting the elements of scalar multiplication using lexical order does not yield the same form.

To address this issue, we propose an algorithm to sort in two steps. The key observation is that in a successive sum expression \( \sum_{i \in s_1} \cdots \sum_{j \in s_n} A \), the names and order of the bound variables \( i, \dots, j \) can be freely permuted. Therefore, a good idea is to normalize AC-equivalence first, where all bound variables are treated uniformly. Afterwards, the order of summation can then be determined based on the position of the bound variables.

% \begin{align*}
%     \sum_{i \in s_1} \sum_{j \in s_2} \bra{i} A \ket{j} \times \bra{j} B \ket{i} 
%     \qquad
%     \sum_{i \in s_2} \sum_{j \in s_1} \bra{i} B \ket{j} \times \bra{j} A \ket{i} \\
%     \sum_{i \in s_1} \sum_{j \in s_2} \bra{i} A \ket{j} \times \bra{j} B \ket{i} 
%     \qquad 
%     \sum_{i \in s_2} \sum_{j \in s_1} \bra{j} A \ket{i} \times \bra{i} B \ket{j} \\
%     \sum_{i \in s_1} \sum_{j \in s_2} \bra{i} A \ket{j} \times \bra{j} B \ket{i} \\
%     \sum_{s_1} \sum_{s_2} \bra{\$1} A \ket{\$0} \times \bra{\$0} B \ket{\$1}
% \end{align*}

In the example above, we first ignore the bound variables and sort the sum body into \( \bra{\bullet} A \ket{\bullet} \times \bra{\bullet} B \ket{\bullet} \). Then, we swap the summations such that the bound variable at the first \( \bullet \) position appears at the outermost position. The results will have the same de Bruijn normal form, namely \( \sum_{s_1} \sum_{s_2} \bra{\$1} A \ket{\$0} \times \bra{\$0} B \ket{\$1} \).


To describe the algorithm in the following, we introduce two key notations. For a term \( e = f(a_1, a_2, \dots, a_n) \), \( \textrm{head}(e) \) denotes the function symbol \( f \), while \( \textrm{arg}(e, i) \) refers to the \( i \)-th argument \( a_i \) of the term. In this context, variables and constants are treated as functions with zero arguments.
\begin{definition}[Order Without Bound Variables]
Let \( \mathcal{B} \) represent the set of bound variables, with the assumption that all bound variables are unique. We also assume that a total order exists over all symbols. The relation \( e_1 =_\mathcal{B} e_2 \) holds if:
\begin{itemize}
    \item \( \textrm{head}(e_1) = \textrm{head}(e_2) \), and for all \( i \), \( \textrm{arg}(e_1, i) =_\mathcal{B} \textrm{arg}(e_2, i) \), or
    \item \( e_1 \in \mathcal{B} \) and \(e_2 \in \mathcal{B}\).
\end{itemize}

The relation \( e_1 <_\mathcal{B} e_2 \) holds between two terms if:
\begin{itemize}
    \item $e_1 \notin \mathcal{B}$ and $e_2 \in \mathcal{B}$, or
    \item $head(e_1) < head(e_2)$, or
    \item $head(e_1) = head(e_2)$, and there exists $n$ with $arg(e_1, n) <_\mathcal{B} arg(e_2, n)$, where $arg(e_1, i) =_\mathcal{B} arg(e_2, i)$ for all $i < n$.
\end{itemize}
\end{definition}
It can be shown that \( e_1 =_\mathcal{B} e_2 \) if and only if neither \( e_1 <_\mathcal{B} e_2 \) nor \( e_2 <_\mathcal{B} e_1 \) holds. The purpose of this ordering is to compare function symbols in a top-down manner while ignoring bound variables. This order enables normalization of terms for AC equivalence.
\begin{definition}[Sort Transformation]
    For a term $e$ with bound variable set $\mathcal{B}$,
    The sort transformation is defined in~\Cref{alg: sort}.
\end{definition}

\begin{algorithm}
    \caption{Sort Transformation}
    \label{alg: sort}
    \begin{algorithmic}[1]
        \Procedure{Sort}{$e, \mathcal{B}$}
            \If{$e \equiv \lambda x : T . e'$}
                \State \Return $\lambda x : T . \textsc{Sort}(e')$
            \ElsIf{$e \equiv \lambda x : \Index. e'$}
                \State \Return $\lambda x : \Index . \textsc{Sort}(e')$
            \ElsIf{$e \equiv f(a_1, \cdots, a_n)$}
                \State $ls := \textsc{Sort}(a_1), \cdots, \textsc{Sort}(a_n)$
                \State $ls := ls$ sorted by $<_\mathcal{B}$
                \State \Return $f(ls)$
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

After sorting, the next step is the \textit{swap transformation}, which arranges successive summations based on the order of bound variables.
\begin{definition}[Swap Transformation]
For a term \( e \) with a sorting result \( \textsc{Sort}(e) \), the swap transformation proceeds by ordering all bound variables according to their first appearances, except in function definitions \( \lambda x \). The swap transformation then reorders the successive summations accordingly.
\end{definition}

Take the term $\sum_{i \in s_2} \sum_{j \in s_1} \bra{i} B \ket{j} \times \bra{j} A \ket{i}$ as an example. Its bound variable set $\mathcal{B} = \{i, j\}$. Assume we have $A < B$, then the sorting result will be $\sum_{i \in s_2} \sum_{j \in s_1} \bra{j} A \ket{i} \times \bra{i} B \ket{j}$. Then we decide that the order for bound variables will be $j < i$ because $j$ appears first in the body. Using the swap transformation, the sorted result will be $\sum_{j \in s_1} \sum_{i \in s_2} \bra{j} A \ket{i} \times \bra{i} B \ket{j}$.

% The order depends on there occurances in the last sorting result. If no occurance, then the order will depend on the set (for sum) and the type (for lambda abstraction only).

%%%%%%%%%%%%%%%%%%%%%%%


% The idea is to assign an order to terms, which is independent on the bound variables. Because we can have terms with nested AC symbols.

% Lastly, we can prove that the equivalence established by this normalization procedure is sound with respect to the semantics.

% \begin{theorem}[Soundness]
%     For any well-formed context \( \Gamma \) and well-typed expressions \( e_1 \) and \( e_2 \), if  $e_1$ and $e_2$ have the same normal form, then \( \sem{e_1} = \sem{e_2} \).
% \end{theorem}

% \begin{proof}
%     The soundness of the term rewriting procedure follows from the fact that each rewriting rule preserves equivalence. Furthermore, the operations in the sort and swap transformations respect the AC-equivalence and SUM-SWAP axioms. Finally, the de Bruijn normalization ensures soundness for \( \alpha \)-equivalence.
% \end{proof}




\section{Examples for labelled Dirac notation}
\newcommand{\tr}{\mathrm{tr}}
\label{sec: examples for labelled}
\begin{itemize}
    \item (LDN-1) \( \ket{s}_Q \otimes \ket{t}_R = \ket{(s, t)}_{(Q, R)} \)
    \item (LDN-2) \( {O_1}_{Q} \cdot {O_2}_{(Q,R)} = ((O_1 \otimes \mathbf{1}_\mathcal{O}) \cdot O_2)_{(Q,R)} \)
    \item (LDN-3) \( M_{r_1} \sum_{i} \ket{(i, i)}_{(r_1, r_2)} = M^T_{r_2} \sum_{i}\ket{(i, i)}_{(r_1, r_2)} \)
    \item (LDN-4) \( \bra{\Phi}_{(x, y)} M_y \cdot N_x \ket{\Phi}_{(x, y)} = \mathrm{tr}(M^T N) \), where $\ket{\Phi} = \sum_{i} \ket{(i, i)}$
    \item (LDN-5) \( \sum_{i} {}_x\bra{i} O_x \ket{i}_x = \mathrm{tr}(O) \)
    \item (LDN-6) \( \sum_{j} {}_y\bra{j} (\sum_{i} {}_x\bra{i} O_{(x,y)} \ket{j}_x) \ket{j}_y = \mathrm{tr}(O) \)
    \item (LDN-7) \( \sum_{i} {}_{(x, y)}\bra{i} O_{(x,y)} \ket{i}_{(x, y)} = \mathrm{tr}(O) \)
    \item (LDN-8) \( \mathrm{tr}_x(\mathrm{tr}_y(O_{((y,z),x)})) = \mathrm{tr}_y(\mathrm{tr}_x(O_{((y,z),x)})) \)
    \item (LDN-9) \( \mathrm{tr}_x(\mathrm{tr}_y(O_{((y,z),x)})) = \mathrm{tr}_{(x, y)}(O_{((y,z),x)}) \)
    \item (LDN-10) \begin{align*}
        & \tr_{((a',(b,b')),c')}\Big[\tr_{r}\Big(U_{(r,(a,b))} \cdot\Big(|s\>_r\<s|\otimes 
        \Big[V_{((a',(b,b')),c')}\cdot 
        \big(|\phi\>_{(a,a')}\<\phi|\otimes \\
        &\qquad |\psi\>_{((b,b'),(c,c'))}\<\psi|\big)
        \cdot V^\dagger_{((a',(b,b')),c')}\Big]
        \Big) \cdot U^\dagger_{(r,(a,b))} \Big)\Big] \\
        =\ &\tr_{(((r,a'),(b,b')),c')}\Big[\big(U_{(r,(a,b))}\cdot V_{((a',(b,b')),c')}\cdot(|s\>_r\otimes |\phi\>_{(a,a')}\otimes |\psi\>_{((b,b'),(c,c'))})\big)\cdot \\
        &\qquad \big(U_{(r,(a,b))}\cdot V_{((a',(b,b')),c')}\cdot(|s\>_r\otimes |\phi\>_{(a,a')}\otimes |\psi\>_{((b,b'),(c,c'))})\big)^\dagger\Big]
    \end{align*}
    \item (LDN-11)    
        \begin{align*}
            \mbox{set}\qquad &U \triangleq \sum_i|i\>\<i|\otimes  P_i \qquad V \triangleq \sum_i|i\>\<i|\otimes Q_i \\
            \mbox{show}\qquad &U_{(a,b)}\cdot W_{(b,c)}\cdot V_{(a,c)} = 
            \sum_i |i\>_a\<i|\otimes \big((P_i)_c\cdot W_{(b,c)}\cdot (Q_i)_c\big)
        \end{align*}
    \item (LDN-12) \( \ket{i}_{a;b}\bra{j} \cdot C_{(b,c)} \cdot D_{(c,d)} = {}_b\bra{j} \cdot C_{(b,c)} \cdot D_{(c,d)} \cdot \ket{i}_{a}\)
    \item (LDN-13) \( (A_{(a,b)} \otimes B_{(c,d)} \otimes C_{(e,f)}) \cdot (D_{(b,c)} \otimes E_{(d,e)}) \cdot (F_{(a,b)} \otimes G_{(c,d)} \otimes H_{(e,f)}) = (A_{(a,b)} \otimes C_{(e,f)}) \cdot (B_{(c,d)} \cdot D_{(b,c)}) \cdot (E_{(d,e)} \cdot G_{(c,d)}) \cdot (F_{(a,b)} \otimes H_{(e,f)})\)
    \item (LDN-14) \( \textsf{CNOT}_{rq}\ket{\textrm{GHZ}}_{pqr} = (\textsf{CNOT}\ket{00})_{rq}\ket{0}_p + (\textsf{CNOT}\ket{11})_{rq}\ket{1}_p \)
    \item (LDN-15) \( \textsf{CNOT}_{pq}\ket{\textrm{GHZ}}_{pqr} = (\textsf{CNOT}\ket{00})_{pq}\ket{0}_p + (\textsf{CNOT}\ket{11})_{pq}\ket{1}_p \)
    \item (LDN-16) \begin{align*}
        \mbox{set}\qquad &\ket{\textrm{GHZ}}\triangleq\sum_i \ket{iii}\bra{iii} \quad M\triangleq\sum_{ij}\ket{ij}\bra{ij}\otimes U_{ij} \quad N \triangleq \sum_i \ket{i}\bra{i} \otimes U_{ii}\\
        \mbox{show}\qquad &M_{prq} \ket{\textrm{GHZ}}_{prq} = N_{rq} \ket{\textrm{GHZ}}_{pqr}
    \end{align*}
    \item (LDN-17) \begin{align*}
        \mbox{set}\qquad &\ket{\textrm{GHZ}}\triangleq\sum_i \ket{iii}\bra{iii} \quad M\triangleq\sum_{ij}\ket{ij}\bra{ij}\otimes U_{ij} \quad N \triangleq \sum_i \ket{i}\bra{i} \otimes U_{ii}\\
        \mbox{show}\qquad &N_{rq} \ket{\textrm{GHZ}}_{pqr} = N_{pq}\ket{\textrm{GHZ}}_{pqr}
    \end{align*}
    \item (LDN-18) \( -\ket{0}_q\ket{+-}_{q_1, q_2} = X_{q_2} \ket{0}_q\ket{+-}_{q_1, q_2} \)
    % \item \( \ket{1}_q \ket{--}_{(q1, q2)} = \textsf{CNOT}_{(q1, q2)} \ket{0}_q \ket{+-}_{(q1, q2)} \)
\end{itemize}