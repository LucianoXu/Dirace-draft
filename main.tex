% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}


% \usepackage[utf8]{inputenc}
% \usepackage[margin=0.8in]{geometry}




\usepackage{color}
\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{graphicx}
% \usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{multirow}
\usepackage{paralist}
\usepackage{hhline}
\usepackage{bm}
\usepackage{longtable}
\usepackage{makecell}
\usepackage{mdframed}

\usepackage{wasysym}
\usepackage{extarrows}
\usepackage{tikz}

% add new commands for comments here
\newcommand{\yx}[1]{\textit{\color{blue}[YX] : #1}}
\newcommand{\lz}[1]{\textit{\color{red}[LZ] : #1}}

\newcommand{\modify}[1]{{\color{red}#1}}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{hyperref}

\usepackage{braket}
\usepackage{cleveref}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}



\newenvironment{ruletable}[1]
{
    \begin{longtable}{cl}
    \caption{#1}\\
    \hline
    \textbf{Rule} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Rule} & \textbf{Description} \\
    \hline
    \endhead

    % \hline
    % \multicolumn{2}{r}{\textit{Continued on the next page}} \\
    \hline
    \endfoot

    \hline
    \endlastfoot
}
{
    \end{longtable}
}



%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
%
\begin{document}
%
\title{Dirace: Practical Proof Automation of Dirac Notation Equations}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% %\titlerunning{Abbreviated paper title}
% % If the paper title is too long for the running head, you can set
% % an abbreviated paper title here
% %
% \author{First Author\inst{1}\orcidID{0000-1111-2222-3333} \and
% Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
% Third Author\inst{3}\orcidID{2222--3333-4444-5555}}
% %
% \authorrunning{F. Author et al.}
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% %
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

Dirac notations are widely used in theoretical reasonings of quantum computation and quantum information.
The previous work proved that the equivalence of basic Dirac notations is decidable, and provided a
corresponding term rewriting system.
This work focuses on developing the theory and tool that practically solves this problem. Compared to the
previous result, this work includes a typing system and a simplified term rewriting system.
A much more efficient algorithm.
And a language and algorithm for labelled Dirac notation is proposed as the final contribution.
We implement the whole algorithm in C++ with a Mathematica backend for theories of scalars, which 
decides the 158 examples in seconds.


% \keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%



%%%%%%%%%%%%%%%%
\newcommand*{\sem}[1]{{\llbracket #1 \rrbracket}}
\newcommand{\DiracDec}{\textsf{DiracDec}}

\newcommand{\reduce}{\triangleright}

\newcommand{\Sort}{\mathsf{Sort}}
\newcommand{\WF}{\mathcal{WF}}

\newcommand{\Index}{\mathsf{Index}}
\newcommand{\Type}{\mathsf{Type}}
\newcommand{\Basis}{\mathsf{Basis}}

\newcommand{\SType}{\mathcal{S}}
\newcommand{\KType}{\mathcal{K}}
\newcommand{\BType}{\mathcal{B}}
\newcommand{\OType}{\mathcal{O}}
\newcommand{\SET}{\mathsf{Set}}

\newcommand{\ZEROK}{\mathbf{0}_\mathcal{K}}
\newcommand{\ZEROB}{\mathbf{0}_\mathcal{B}}
\newcommand{\ZEROO}{\mathbf{0}_\mathcal{O}}

\newcommand{\PAIR}{\mathsf{PAIR}}

\newcommand{\ZERO}{\mathsf{0}}
\newcommand{\ONE}{\mathsf{1}}
\newcommand{\ADDS}{\mathsf{ADDS}}
\newcommand{\ADD}{\mathsf{ADD}}
\newcommand{\MULS}{\mathsf{MULS}}
\newcommand{\MUL}{\mathsf{MUL}}
\newcommand{\CONJ}{\mathsf{CONJ}}
\newcommand{\CJG}{\mathsf{CJG}}
\newcommand{\ADJ}{\mathsf{ADJ}}
\newcommand{\DELTA}{\mathsf{DELTA}}
\newcommand{\DOT}{\mathsf{DOT}}
\newcommand{\SCR}{\mathsf{SCR}}
\newcommand{\TSR}{\mathsf{TSR}}
\newcommand{\KET}{\mathsf{KET}}
\newcommand{\BRA}{\mathsf{BRA}}
\newcommand{\ONEO}{\mathbf{1}_\mathcal{O}}
\newcommand{\OUTER}{\mathsf{OUTER}}
\newcommand{\MULK}{\mathsf{MULK}}
\newcommand{\MULB}{\mathsf{MULB}}
\newcommand{\MULO}{\mathsf{MULO}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

In 1939, Dirac proposed his notation~\cite{dirac1939new} for quantum mechanics, which is designed to represent linear algebra formulae in a compact and convenient way.
For instance, $a\ket{\psi} + b\ket{\phi}$ indicates the addition of two vectors, i.e., the superposition of two states $\ket{\psi}$ and $\ket{\phi}$.
Dirac notation is also widely accepted as the working language in quantum computation and quantum information.
The reasonings of Dirac notations play a fundamental role, but there was few works on automating this procedure.


The absence of a working Dirac notation solver is also a main obstacle for proof automation of quantum programming languages.
In these works, Dirac notation are used to define the program states, operations and assertions. In order to automate the verification procedure,
we need to simplify and check the equivalence of pre-conditions. 


Recently, the work by Yingte et al.[] provides a theory to decide the equivalence of Dirac notations, as well as a prototype implementation in Mathematica.
They proved that the equivalence of basic Dirac notations are decidable.
Their system sticks with a pure term rewriting system, which allows to prove important properties such as confluence and termination.
Even though, there is still a gap to a practical solver for Dirac notation equivalence.
The Mathematica implementation is hard to be integrated into other tools. 
The second concern is the efficiency. To decide the theory $E$, \DiracDec\ iterates all possible permutations, which is simple and direct but has factorial complexity.
And lastly, the previous work does not consider labelled Dirac notation.
The original work cannot intergrate with well with the Scalar system in mathematica.
And there were a few examples that failded to decide.





This work refines the pure term-rewriting based system into a hybrid decision procedure,
overcomes the problems mentioned above and focuses on practical
automated equational reasonings. Our main contributions are:
\begin{itemize}
    \item We propose a rigorous typing system for Dirac notation. Defined symbols (e.g., transpose and trace) are modelled by functions.
        Also, the typing system removes the difficulty of disambiguation, therefore the language and the term rewriting system are much simplified.
    \item An efficient algorithm to decide the extra equational theories $E$ is provided. The basic idea is normalization by sorting, which considers the interplay of AC symbols, SUM-SWAP and $\alpha$-equivalence. This algorithm reduces the complexity from the factorial level to the polynomial level.
    \item The language to support variable labels is proposed.
\end{itemize}

\paragraph{Related Work} Other previous works explore the language and decision procedure to express quantum computation differently.





\section{Preliminary and Motivation}
The preliminary for the problem are two folds: Dirac notation and the equational logic in universal algebra.

Quantum states live in complex Hilbert spaces. We use vectors in the space to descirbe pure quantum states, and operations corresponds to linear transformations. 
In 1939, Dirac proposed his notation~\cite{dirac1939new} for quantum mechanics, which is essentially a wrapping of the linear algebra language. 
Dirac notation uses the ket $\ket{i}$ and the bra $\bra{i}$ to indicate bases of the space and the dual space. Together with other variable symbols, they are composed with each other in sequence, and the composition will be interpreted into different operations, depending on the type of operands. For example, $\braket{i|j}$ represents the inner product of $\bra{i}$ and $\ket{j}$, which is a scalar, while $\ket{i}\bra{j}$ represents the outer product, resulting in an operator. 
\[
    \braket{i|\phi}\braket{\psi|j} = \bra{i} (\ket{\phi}\bra{\psi}) \ket{j},
\]
and they are equivalent for all variables.
Dirac notation also use $\otimes$ to indicate the vectors and operators in the tensor product space.

In this manner, we can express long formulae in succint Dirac notations. The notation further enjoys the property that the interpretation is independent on the order of composition, thus parentheses can be omitted. For example, the formula \(\bra{i}\ket{\phi}\bra{\psi}\ket{j}\) can be understood as

With the concrete basis, Dirac notations can be interpreted as matrices. For example ...



We use universal algebra and equational logic to formally represent Dirac notations and the reasoning procedure in computers.

\yx{mention the dilemma of simplicity and efficiency}


\section{Language, Typing and Semantics}
The syntax of Dirac notations involves three layers: the index, the type and the term. 
Index represents classical datatypes, and they appear in type expression to denote the type of Hilbert spaces and sets.


\begin{definition}[language syntax]
    The syntax for type indices are defined as
    \begin{align*}
        \sigma ::=\ & x \mid \sigma_1 \times \sigma_2 \mid \mathsf{Bit}.
    \end{align*}
    The syntax for Dirac notation types is defined as 
    \begin{align*}
        T ::=\ & \Basis(\sigma) \mid \SType \mid \KType(\sigma) \mid \BType(\sigma) \mid \OType(\sigma_1, \sigma_2) \mid T_1 \to T_2 \mid \forall x.T \mid \SET(\sigma). \\
    \end{align*}
    The syntax for Dirac notation terms is defined as
    \begin{align*}
        e ::=\ & x \mid \lambda x : T.e \mid \mu x.e \mid e_1\ e_2 \mid e_1 \circ e_2 \\
        & |\ \hat{0} \mid \hat{1} \mid (e_1, e_2) \\
        & |\ 0 \mid 1 \mid \ADDS(e_1 \cdots e_n)  \mid e_1 \times \cdots \times e_n \mid e^*  \mid \delta_{e_1, e_2} \mid \DOT(e_1\ e_2) \\
        & |\ \ZEROK(\sigma) \mid \ZEROB(\sigma) \mid \ZEROO(\sigma_1, \sigma_2) \mid \ONEO(\sigma) \\
        & |\ \ket{e} \mid \bra{t} \mid e^\dagger \mid e_1.e_2 \mid \ADD(e_1 \cdots e_n) \mid e_1 \otimes e_2 \\
        & |\ \MULK(e_1\ e_2) \mid \MULB(e_1\ e_2) \mid \OUTER(e_1\ e_2) \mid \MULO(e_1\ e_2) \\
        & |\ \mathbf{U}(e) \mid e_1 \star e_2 \mid \sum_{e_1} e_2.
    \end{align*}
\end{definition}
 % after consideration I still think keep DOT as binary is the best choice. It reduces the unstability of complicated matching in sequences.
Here $i$ is a natural number and $\$i$ represents the $i$-th bound variable in de Bruijn notation. 
Compared to [?], this syntax for Dirac notations merges the symbols with overlapped properties, such as the addition and scaling symbols for ket, bra and operator.
Here $\ADDS$ and $\ADD$ are two different AC symbols representing the scalar addition and the linear algebra addition respectively. They will be denoted as $a_1 + \cdots + a_n$ and $X_1 + \cdots + X_n$.
There are five kinds of linear algebra multiplications among ket, bra and operator, whose properties are similar but still diverge to some extent. For example, the rules $(O_1 \cdot O_2) \cdot K\ \reduce\ O_1 \cdot (O_2 \cdot K)$ and $B \cdot (O_1 \cdot O_2) \ \reduce\ (B \cdot O_1) \cdot O_2$ indicate that the sorting of multiplication sequences depends on the subterm types. To avoid frequent but unnecessary type checkings, we encode the typing information by using five different symbols, namely $\DOT$, $\MULK$, $\MULB$, $\OUTER$ and $\MULO$. They are denoted as $B\cdot K$, $K_1 \cdot K_2$, $B_1 \cdot B_2$, $K \cdot B$ and $O_1 \cdot O_2$, respectively.

Usually, the sum body is specified by an abstraction. Therefore we use notation $\sum_s X$ to denote $\sum_{x \in s} \lambda x : T . X$ as well.
 


\subsection{Typing System}


The type checking of our language involves maintaining a well-formed environment and context $E[\Gamma]$, which is defined as follows.

\begin{definition}[environment and context]
    \begin{align*}
        E ::=\ & [] \mid E; x : \Index \mid E; x : T \mid E; x := t : T. \\
        \Gamma ::=\ & [] \mid \Gamma; x : \Index \mid \Gamma; x : T.
    \end{align*}
\end{definition}

The environment and the context are sequences of assumptions $x : T$ or definitions $x := t : T$.
With the environment, we can declare the type of variable symbols, and encode more operations on Dirac notations as definitions, such as the trace operator. Also, the existence of lambda abstractions requires a context of bound variables.


We say an expression $t$ has type $X$ in context $E[\Gamma]$, if the typing judgement $E[\Gamma] \vdash t : X$ can be proved through the typing rules in~\Cref{sec: full typing rules}. Here we present and explain the rules selectively. Firstly, well-formed contexts $\WF(E)[\Gamma]$ are built in the incremental way, e.g.:
\[
    \frac{}{\WF([])[]}
    \qquad
    \frac{\WF(E)[] \qquad x \notin E}{\WF(E; x : \Index)[]}
    \qquad
    \frac{E[]\vdash t:T \qquad x \notin E}{\WF(E; x:=t:T)[]}.
\]
Starting from an empty context, we can assume new index symbols, and assume or define symbols with checked types. Based on the well-formed context, typing judgements can be proved by information from $E[\Gamma]$, or built inductively. In the following rules, for example, the condition $x : \Index \in E[\Gamma]$ is true if $E$ or $\Gamma$ has the assumption in their sequences, and $\sigma \times \tau$ is a index if both $\sigma$ and $\tau$ are typed as the index. $\KType(\sigma)$ and $\OType(\sigma, \tau)$ will be valid types for kets and operators, if their arguments are typed as the index.
\begin{gather*}
    \frac{\WF(E)[\Gamma] \qquad x : \Index \in E[\Gamma]}{E[\Gamma] \vdash x : \Index}
    \qquad
    \frac{E[\Gamma] \vdash \sigma : \Index \qquad E[\Gamma] \vdash \tau : \Index}{E[\Gamma] \vdash \sigma \times \tau : \Index} \\
    \\
    \frac{E[\Gamma] \vdash \sigma : \Index}{E[\Gamma] \vdash \KType(\sigma) : \Type}
    \qquad
    \frac{E[\Gamma] \vdash \sigma : \Index \qquad E[\Gamma] \vdash \tau : \Index}{E[\Gamma] \vdash \OType(\sigma, \tau) : \Type}
\end{gather*}

The Dirac notations will then be typed accordingly. For example, the ket syntax $\ket{t}$ has type $\KType(\sigma)$, if $t$ is typed as a basis term of index $\sigma$. Also, the inner product of a bra and a ket with the same type index $\sigma$ is typed as the scalar. This corresponds to the constraint of inner products that vectors should be in the same Hilbert space.
\begin{gather*}
    \frac{E[\Gamma]\vdash t : \Basis(\sigma)}{E[\Gamma] \vdash \ket{t} : \KType(\sigma)}
    \qquad
    \frac{E[\Gamma]\vdash B : \BType(\sigma) \qquad E[\Gamma]\vdash K : \KType(\sigma)}{E[\Gamma] \vdash B \cdot K : \SType}
\end{gather*}

The typing for functions and applications follow the common practice. We specify the syntax and typing rule for functions of indices $\mu x. t$: here $x$ is a bound variable of typed as $\Index$, and the type $U\{x/u\}$ of application $(t u)$ is obtained by replacing $x$ with the index instance $u$.


\begin{gather*}
    \frac{E[\Gamma; x : T] \vdash t : U}{E[\Gamma] \vdash (\lambda x : T . t) : T \to U}
    \qquad
    \frac{E[\Gamma] \vdash t:U \to T \qquad E[\Gamma] \vdash u:U}{E[\Gamma] \vdash (t\ u):T} \\
    \\
    \frac{E[\Gamma; x : \Index] \vdash t : U}{E[\Gamma] \vdash (\mu x.t) : \forall x.U}
    \qquad
    \frac{E[\Gamma] \vdash t:\forall x.U \qquad E[\Gamma] \vdash u : \Index}{E[\Gamma] \vdash (t\ u):U\{x/u\}}
\end{gather*}


The big operator sum is modelled by folding a function on a set, therefore the typing rule is as follows:
\[
    \frac{E[\Gamma] \vdash s : \SET(\sigma) \qquad E[\Gamma] \vdash f : \Basis(\sigma) \to \KType(\tau)}{E[\Gamma] \vdash \sum_{s} f : \KType(\tau)}.
\]

And lastly we have the typing rules for composition $x \circ y$. As is the case for casual Dirac notation, the typing of composition depends on the types of operands.
\begin{gather*}
    \frac{E[\Gamma] \vdash x : \SType \qquad E[\Gamma] \vdash y : \KType(\sigma)}{E[\Gamma] \vdash x \circ y : \KType(\sigma)}
    \qquad
    \frac{E[\Gamma] \vdash x : \OType(\sigma, \tau) \qquad E[\Gamma] \vdash y : \KType(\tau)}{E[\Gamma] \vdash x \circ y : \KType(\sigma)}
\end{gather*}

\begin{lemma}
    The typing of expressions are decidable and unique.
\end{lemma}

\subsection{Semantics}

Semantics assign the meanings to the expressions, and the goal of the decision procedure is to decide whether
two expressions have the equivalent semantics. We consider two ways of definition: the axiomatic equations and the denotational semantics.

The denotational way interprets every expression as a linear algebra concept, and equivalence is considered in the common mathematical sense.
This explanation formalizes the original definition of Dirac notations, and best describes the target of the decision procedure.

The semantics by equations, on the other hand, is an abstraction and axiomization. From the operational view, each equation declares a 
valid rewriting operation, and two expressions are equiavlent if and only if they can be rewritten into the same form using the axioms.

\section{Decision procedure for Dirac notations}

The following two sections talk about how to decide the equivalence of Dirac notations.
In the previous work, the equational axioms are separated into two parts: a set $E$ of equations that can not be decided by rewriting, and the remaining equations to be decided by term rewriting.
Here, the equational theories $E$ inlude:
\begin{itemize}
    \item Commutativity of symbols $a + b$, $a\times b$ and $\delta_{s, t}$,
    \item $\alpha$-equivalence of bound variables, i.e., $\lambda x.t = \lambda y . t\{x/y\}$,
    \item swapping successive summations, i.e., $\sum_{i \in s_1} \sum_{j \in s_2} A = \sum_{j \in s_2} \sum_{i \in s_1}A$, and
    \item equational theories for scalars.
\end{itemize}

In this work, the general idea is to carry through the normalization procedure, so that semantical equivalence can be directly checked by the syntax of normal forms. The procedure of the normalization is displayed in~\Cref{fig: normalization}.

\input{flowchart.tex}

The last three steps deals with the equational theory $E$, while the first three steps use term rewriting to work on the structure of Dirac notations.


\subsection{Normalization modulo $E$ by Term Rewriting}
Term rewriting rules, written as $l -> r$, are used to normalize terms by recursively matching the subterms of the term with the left hand side $l$, and replace them with the corresponding right hand side $r$. The procedure terminates when no more rewritings can be made, and the order of rewritings will be irrelevant if the term rewriting system is \textit{confluent}, which is a desirable property.

To express the term rewriting system, the previous work adheres to use the naive universal algebra, where each function symbol has a fixed arity, and the left hand side pattern only allows constant symbols and variables. This constraint enables them to check the confluence and termination of their term rewriting system with other tools.

Here to enable more efficient algorithms, our langauge uses AC symbols with a variable arity.

The full list of rewriting rules are in~\Cref{sec: rewriting rules}. Here we present some of them to illustrate the design idea.

When using variable arity AC symbols, the associativity can be normalized by the following flattening rule:

\[
a_1 + \cdots + (b_1 + \cdots + b_m) + \cdots + a_n
\ \reduce\ a_1 + \cdots + b_1 + \cdots + b_m + \cdots + a_n,
\]

while commutativity is left for a sorting algorithm later on.

The term rewriting rule follows the system in the previous work.

The general idea is to reduce all the possible calculations, and transform multiplication into tensor product as much as possible.

And some rules exists for completeness. As an example, given the following rule snippet
\begin{align*}
    %
    & \text{(R-DOT10)}
    && (B \cdot O) \cdot K \ \reduce\ B \cdot (O \cdot K), \\
    %
    & \text{(R-DOT11)}
    && \bra{(s, t)} \cdot ((O_1 \otimes O_2) \cdot K) \ \reduce\ ((\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2)) \cdot K, \\
    %
    & \text{(R-MULB10)}
    && \bra{(s, t)} \cdot (O_1 \otimes O_2)\ \reduce\ (\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2),
\end{align*}
the normalization of term $(\bra{(s, t)} \cdot (O_1 \otimes O_2)) \cdot K$ have two rewriting paths: (a). apply (R-MULB10) and get $((\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2)) \cdot K$, or
(b). first apply (R-DOT10) and sort the term into $\bra{(s, t)} \cdot ((O_1 \otimes O_2) \cdot K)$, and then apply (R-DOT11) to get the same result. Here (R-DOT11) is for completeness of cases similar to this example.

One important technique revealed in the previous work is the expansion of variables:

\begin{gather*}
    \frac{E[\Gamma] \vdash K : \KType(\sigma)}{E[\Gamma] \vdash K \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(\bra{i}\cdot K).\ket{i}}
    \qquad \qquad
    \frac{E[\Gamma] \vdash B : \BType(\sigma)}{E[\Gamma] \vdash B \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(B \cdot \ket{i}).\bra{i}} \\
    \\
    \frac{E[\Gamma] \vdash O : \OType(\sigma, \tau)}{E[\Gamma] \vdash O \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)} \sum_{j \in \mathbf{U}(\tau)}(\bra{i} \cdot O \cdot \ket{j}).(\ket{i} \cdot \bra{j})}
\end{gather*}
The above three rules are obviously not terminating, and this is why we have the rewriting-expansion-rewriting steps in the decision procedure. On the other hand, we discovered that doing the expansion on all variables only once is already sufficient.

\begin{lemma}
    Let $\text{expand}(e)$ indicate the result of expanding all variables in $e$ once.
    For all well-typed term $e$ in $E[\Gamma]$, we have $\text{expand}(\text{expand}(e)) \downarrow = \text{expand}(e)\downarrow$.
\end{lemma}
\begin{proof}
\end{proof}



\section{Deciding Equational Theory $E$}

The previous work did not consider the algorithm to decide equational theory $E$. In their Mathematica implementation, it is implemented by a unification, which tries to find a substitution of summation bound variables that makes the two expressions syntactically equivalent. To decide AC-equivalence and (SUM-SWAP), they iterate through all the permutations, and the complexity is factorial to the number of AC symbol arguments and successive summations.

A standard approach to decide this permutation equivalence is to normalize by sorting with a given order. For example, given the dictionary order $a < b < c$, the term $b + c + a$ (and any other AC equivalent ones) will be normalized into $a + b + c$. For our setting, there are two related difficulties: how to assign such an order to all terms in our language, and how to normalize with respect to AC-equivalence and (SUM-SWAP) at the same time.






At last, we will prove that equivalence by this normalization procedure is sound in the semantics. 

\begin{theorem}[soundness]
    For any well-formed context $E[\Gamma]$ and well-typed expressions $e_1$ and $e_2$, if $e_1\downarrow = e_2\downarrow$, then $\sem{e_1} = \sem{e_2}$.
\end{theorem}
\begin{proof}
    
\end{proof}

% Labelled Dirac Notation

\input{labelled}

\section{Implementation and Case Study}



\section{Conclusion}

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Consideration}
\begin{itemize}
    \item Sorting requires that alpha equivalent terms have the same syntax.
    \item de Bruijn expression satisfies this requirement, but the typing and substitution becomes very complicated in the type index scenario.
    \item only compute de Bruijn form in the equivalence checking and sorting phase.
    \item pipeline: 
        \begin{enumerate}
            \item preprocessing
            \item rename unique bound variable names
            \item 1st rewritings
            \item variable expansion
            \item 2nd rewritings 
            \item sorting modulo bound variables
            \item sorting successive sum. The order depends on there occurances in the last sorting result. If no occurance, then the order will depend on the set (for sum) and the type (for lambda abstraction only).
            \item computing de Bruijn
        \end{enumerate}

    \item I found that typing of inner bound variables also requires modifying the context.
    Need to modify the tree visiting algorithm
    (Typed term rewriting with bound variables is not that easy)    
\end{itemize}

\section{TODO}
\begin{itemize}
    \item implemented trace output for the whole pipeline.
    \item better output.
    \item add Mathematica support for scalars
    \item output trace to Coq
    \item consider labelled Dirac notations
    \item better trace output
    \item better error logic
    \item better format output
    \item remove term bank and hash consing
\end{itemize}

\section{Things to Note}
\begin{itemize}
    \item The context should also be maintained during rewriting matching.
    \item We don't allow eta reduction. It will intertwine with SUM-SWAP and break the confluence.
    \item In each Delta reduction, the bound variables are replaced with unique variables. This should help solve the problem of conflicting variable names during substitution.
    \item I guess it may still be necessary to try all different bound variable assignments.
    \item the $\bar{U_{AC}}$, $\bar{U_{BC}}$ terms can be modelled by quantum registers.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\texttt{Diracoq} language}

\begin{align*}
    cmd ::=&\ \texttt{Def}(\texttt{ID}\ term) \\
        &|\ \texttt{Def}(\texttt{ID}\ term\ type) \\
        &|\ \texttt{Var}(\texttt{ID}\ term) \\
        &|\ \texttt{Check}(term) \\
        &|\ \texttt{Show}(\texttt{ID}) \\
        &|\ \texttt{ShowAll} \\
        &|\ \texttt{Normalize}(term) \mid \texttt{Normalize}(term\ \textsf{Trace}) \\
        &|\ \texttt{CheckEq}(term\ term) \\
    type ::=&\ \texttt{Type} \mid \texttt{Arrow}(type\ type) \\
            &|\ \texttt{Base} \\
    term ::=&\ \texttt{Type} \mid \texttt{fun}(\texttt{ID}\ type\ term) \mid \texttt{apply}(term\ term) \mid \texttt{ID} \\
\end{align*}

Comment \texttt{(* ... *)} can be inserted between commands.

These are tye parsing rules for different expressions:
\begin{itemize}
    \item \texttt{Def ID := term.} --- \texttt{Def(ID term)}
    \item \texttt{Def ID := term : type.} --- \texttt{Def(ID term type)}
    \item \texttt{Var ID : type.} --- \texttt{Var(ID type)}
    \item \texttt{Check ID.} --- \texttt{Check(term)}
    \item \texttt{Show ID.} --- \texttt{Show(ID)}
    \item \texttt{ShowAll.} --- \texttt{ShowAll}
    \item \texttt{Normalize term.} --- \texttt{Normalize(term)}
    \item \texttt{Normalize term with trace.} --- \texttt{Normalize(term Trace)}
    \item \texttt{Check term = term.} --- \texttt{CheckEq(term term)}
    \item \texttt{T1 -> T2} --- \texttt{Arrow(T1 T2)}.
    \item \texttt{forall x. T} --- \texttt{Forall(x T)}
    \item \texttt{(e1, e2)} --- \texttt{PAIR(e1 e2)}
    \item \texttt{fun x : T => e} --- \texttt{fun(x T e)}
    \item \texttt{idx x => e} --- \texttt{idx(x e)}
    \item \texttt{e1 @ e2} --- \texttt{COMPO(e1 e2)}
    \item \texttt{e1 + ... + en} --- \texttt{ADDG(e1 ... en)}
    \item \texttt{e1 * ... * en} --- \texttt{STAR(e1 ... en)}
    \item \texttt{e1\^{}*} --- \texttt{CONJ(e1)}
    \item \texttt{delta(e1, e2)} --- \texttt{DELTA(e1 e2)}
    \item \texttt{|e>} --- \texttt{KET(e)}
    \item \texttt{<e|} --- \texttt{BRA(e)}
    \item \texttt{e1\^{}D} --- \texttt{ADJ(e1)}
    \item \texttt{e1.e2} --- \texttt{SCR(e1 e2)}
    \item \texttt{Sum(i in s, e)} --- \texttt{SSUM(i s e)}
\end{itemize}

These symbols will be transformed into internal language:
\begin{itemize}
    \item $A \circ B$ : $S \circ S$, $S \circ K$, $S \circ B$, $S \circ O$, $K \circ S$, $K \circ K$, $K \circ B$, $B \circ S$, $B \circ K$, $B \circ B$, $B \circ O$, $O \circ S$, $O \circ K$, $O \circ O$, $f\circ a$ (arrow), $f\circ a$ (index).
    \item \texttt{STAR(a ... b)} :  $\sigma_1 \times \sigma_2$, $\MULS(a \cdots b)$, $O_1 \otimes O_2$, $ M_1 \star M_2$
    \item \texttt{ADDG(e1 ... en)} : $\ADDS(e1 \cdots en)$, $\ADD(e1 \cdots en)$
    \item \texttt{SSUM(i S e)} : \texttt{SUM(s FUN(i T e))}
\end{itemize}

% \begin{credits}
%     \subsubsection{\ackname} A bold run-in heading in small font size at the end of the paper is
%     used for general acknowledgments, for example: This study was funded
%     by X (grant number Y).
% \end{credits}
    
    


%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{ref}
%

\appendix
\include{appendix}

\end{document}