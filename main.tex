% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}


% \usepackage[utf8]{inputenc}
% \usepackage[margin=0.8in]{geometry}




\usepackage{color}
\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{graphicx}
% \usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{multirow}
\usepackage{paralist}
\usepackage{hhline}
\usepackage{bm}
\usepackage{longtable}
\usepackage{makecell}
\usepackage{mdframed}

\usepackage{wasysym}
\usepackage{extarrows}
\usepackage{tikz}

% add new commands for comments here
\newcommand{\yx}[1]{\textit{\color{blue}[YX] : #1}}
\newcommand{\lz}[1]{\textit{\color{red}[LZ] : #1}}

\newcommand{\modify}[1]{{\color{red}#1}}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{hyperref}

\usepackage{braket}
\usepackage{cleveref}

\input{lstlisting}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}



\newenvironment{ruletable}[1]
{
    \begin{longtable}{cl}
    \caption{#1}\\
    \hline
    \textbf{Rule} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Rule} & \textbf{Description} \\
    \hline
    \endhead

    % \hline
    % \multicolumn{2}{r}{\textit{Continued on the next page}} \\
    \hline
    \endfoot

    \hline
    \endlastfoot
}
{
    \end{longtable}
}

% define C++ logo
\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}


%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
%
\begin{document}
%
\title{Dirace: Practical Proof Automation of Dirac Notation Equations}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% %\titlerunning{Abbreviated paper title}
% % If the paper title is too long for the running head, you can set
% % an abbreviated paper title here
% %
% \author{First Author\inst{1}\orcidID{0000-1111-2222-3333} \and
% Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
% Third Author\inst{3}\orcidID{2222--3333-4444-5555}}
% %
% \authorrunning{F. Author et al.}
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% %
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

    Dirac notations is the fundamental language in quantum computation and quantum information reasoning. Recently, the term rewriting system DiracDec~\cite{diracdec} was introduced to automate equational reasoning with Dirac notations, a critical yet time-intensive component of formalization tasks. This work bases upon and extends DiracDec, aiming to develop a solver optimized for practical applications. Enhancements include an improved typing system, a simplified language and rewriting system, more efficient algorithms, and added support for labelled Dirac notations. The solver Dirace, implemented in \CC\ with a Mathematica backend, demonstrates superior decision-making power and computational efficiency, successfully addressing all examples in its benchmark suite.


% \keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%



%%%%%%%%%%%%%%%%
\newcommand*{\sem}[1]{{\llbracket #1 \rrbracket}}
\newcommand{\DiracDec}{\textsf{DiracDec}}

\newcommand{\reduce}{\triangleright}

\newcommand{\Sort}{\mathsf{Sort}}
\newcommand{\WF}{\mathcal{WF}}

\newcommand{\Index}{\mathsf{Index}}
\newcommand{\Type}{\mathsf{Type}}
\newcommand{\Basis}{\mathsf{Basis}}

\newcommand{\SType}{\mathcal{S}}
\newcommand{\KType}{\mathcal{K}}
\newcommand{\BType}{\mathcal{B}}
\newcommand{\OType}{\mathcal{O}}
\newcommand{\SET}{\mathsf{Set}}

\newcommand{\ZEROK}{\mathbf{0}_\mathcal{K}}
\newcommand{\ZEROB}{\mathbf{0}_\mathcal{B}}
\newcommand{\ZEROO}{\mathbf{0}_\mathcal{O}}

\newcommand{\PAIR}{\mathsf{PAIR}}

\newcommand{\ZERO}{\mathsf{0}}
\newcommand{\ONE}{\mathsf{1}}
\newcommand{\ADDS}{\mathsf{ADDS}}
\newcommand{\ADD}{\mathsf{ADD}}
\newcommand{\MULS}{\mathsf{MULS}}
\newcommand{\MUL}{\mathsf{MUL}}
\newcommand{\CONJ}{\mathsf{CONJ}}
\newcommand{\CJG}{\mathsf{CJG}}
\newcommand{\ADJ}{\mathsf{ADJ}}
\newcommand{\DELTA}{\mathsf{DELTA}}
\newcommand{\DOT}{\mathsf{DOT}}
\newcommand{\SCR}{\mathsf{SCR}}
\newcommand{\TSR}{\mathsf{TSR}}
\newcommand{\KET}{\mathsf{KET}}
\newcommand{\BRA}{\mathsf{BRA}}
\newcommand{\ONEO}{\mathbf{1}_\mathcal{O}}
\newcommand{\OUTER}{\mathsf{OUTER}}
\newcommand{\MULK}{\mathsf{MULK}}
\newcommand{\MULB}{\mathsf{MULB}}
\newcommand{\MULO}{\mathsf{MULO}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

In 1939, Dirac proposed his notation~\cite{dirac1939new} for quantum mechanics, which is designed to represent linear algebra formulae in a compact and convenient way.
For instance, $a\ket{\psi} + b\ket{\phi}$ indicates the addition of two vectors, i.e., the superposition of two states $\ket{\psi}$ and $\ket{\phi}$.
Dirac notation is now widely accepted as the working language in quantum computation and quantum information. The reasonings of Dirac notation play a fundamental role in research and application, just like boolean and integer logic to classical computer science. 
For example, formalization works of quantum algorithms and quantum programming languages involves plenty of equational proofs of Dirac notation, which are critical, repeating but time-intensive jobs.
Dirac notation are also used in quantum programming languages to define the program states, operations and assertions. In order to automate the verification procedure, we need to simplify and check the equivalence of pre-conditions. 
However, unlike the existence of SAT and SMT solver, we are still in need of a working Dirac notation solver, and this absence has become an obstacle of many areas.

Recently, Xu et al.~\cite{diracdec} proposed a theory to decide the equivalence of Dirac notations, as well as a prototype implementation in Mathematica called DiracDec.
They proved that the equivalence of basic Dirac notations are decidable.
Their decision procedure sticks with a pure term rewriting system, which allows to prove important properties such as confluence and termination of the system.
Even though, there is still a gap between DiracDec and a practical solver for Dirac notation equivalence.

One problem is the algorithm efficiency for equivalence out of the scope of rewritings. DiracDec decides the whole equational theory by rewriting modulo $E$, where $E$ is a set of equational axioms that cannot be decided by normalization in rewritings, e.g. the associativity and commutativity (AC) of some function symbols. DiracDec uses a direct by inefficient algorithm to decide $E$, which search through all possible permutations and has factorial complexity.
This is witnessed in their evaluation: DiracDec is not good at dealing with "computational" examples, which has many AC symbols and are therefore time consuming.

Another problem is the lack of labelled Dirac notations.
which makes the reasoning more convenient and scaleable.

One last problem is about usability.
The typing of DiracDec only deals with Dirac notations, which is not sufficient for a working scenario, where defined symbols are desirable, and variables have their typing assumptions in the context.
Moreover, to avoid type checking during term rewriting, DiracDec uses different symbols for the same casual notation to disambiguate, which 
is not close to the natural way of using the langauge, and makes the system bloated.
It is hard to integrate the Mathematica implementation as solvers into into other tools.  
Although DiracDec solve most examples in the benchmark, including some very complicated equations, there are still a few examples that DiracDec failds to decide.



Aimming at building a practical solver, this work bases on and extends the DiracDec result, transform the term rewriting system into a hybrid decision procedure, and overcomes the problems mentioned above. Our main contributions and techniques are:
\begin{itemize}
    \item An efficient algorithm to decide the extra equational theories $E$. The basic idea is normalization by sorting, which considers the interplay of AC symbols, SUM-SWAP and $\alpha$-equivalence. This algorithm reduces the complexity from the factorial level to the polynomial level.
    \item The support for constant register labels. The equivalence decision of labelled Dirac notations is then reduced into the unlabelled situation.
    \item A more usable \CC\ solver Dirace with usable language and typing. Defined symbols (e.g., transpose and trace) are modelled by functions.
\end{itemize}

As an evaluation, we tested Dirace on the benchmark of DiracDec and new example for labelled Dirac notations. Dirace successfully decides all the examples that are expressable in its language, including those failed by DiracDec because of complexity or insufficient decision power.





\section{Preliminary and Motivation}
The preliminary for the problem are two folds: Dirac notation and the equational logic in universal algebra.

Quantum states live in complex Hilbert spaces. We use vectors in the space to descirbe pure quantum states, and operations corresponds to linear transformations. 
Dirac notation are used to express the linear algebra formula in a convenient and compat way.
It uses the ket $\ket{i}$ and the bra $\bra{i}$ to indicate bases of the space and the dual space. Together with other variable symbols, they are composed with each other in sequence, and the composition will be interpreted into different operations, depending on the type of operands. For example, $\braket{i|j}$ represents the inner product of $\bra{i}$ and $\ket{j}$, which is a scalar, while $\ket{i}\bra{j}$ represents the outer product, resulting in an operator. 
Dirac notation also use $\otimes$ to indicate the vectors and operators in the tensor product space.

Dirac notation further enjoys the property that the interpretation is independent on the order of composition, thus parentheses can be omitted. For example, the formula \(\bra{i}\ket{\phi}\bra{\psi}\ket{j}\) can be understood as
\[
    \braket{i|\phi}\braket{\psi|j} = \bra{i} (\ket{\phi}\bra{\psi}) \ket{j},
\]
and they are equivalent for all variables.

With the concrete basis, Dirac notations can be interpreted as matrices. For example, the ket of two basis of qubit states are column vectors $\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}$ and $\ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}$, and the corresponding bras are row vectors in the dual space $\bra{0} = \begin{bmatrix} 1 & 0 \end{bmatrix}$ and $\bra{1} = \begin{bmatrix} 0 & 1 \end{bmatrix}$.
The calculation between Dirac notations then corresponds to matrix operatoins. For example, inner product $\braket{0| 1} = \begin{bmatrix} 0 & 1 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix} = 0$, and tensor product $\ket{0} \otimes \ket{1} = \ket{(0, 1)} = \begin{bmatrix} 1 \\ 0 \end{bmatrix} \otimes \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}$.

In practice, Dirac notations are combined with other syntax for better expressiveness. For example, the big operator sum $\sum_{i \in S} A$ are used in theoretical reasonings. We also use labelled Dirac notation, where Dirac notations are subscripted with registers to denote the quantum system in consideration, e.g. $\ket{i}_q \otimes \ket{i}_r$.

We use universal algebra and equational logic to formally represent Dirac notations and the reasoning procedure.
A universal algebra defines a signature of function symbols and the axioms. Terms in the algebra are constructed by constants, variables or function application on terms. In our case of Dirac notation, the signature consists of constructors and operations like $\ket{i}$ or $A \otimes B$, and the axioms Dirac notation equivalenc rules with equational logic.

Here is an example proof of a equivalence lemma.
\begin{example}
    Let $q$ and $r$ be two quantum systems on $\mathcal{H}_T$ space. Let $M$ be a quantum operation on $\mathcal{H}_T$,
    and $\ket{\Phi} = \sum_{i \in T} \ket{i}\otimes \ket{i}$ be the maximally entangled state, then we have
    \[
    M_q \ket{\Phi}_{q; r} = M_r^T \ket{\Phi}_{q; r}.
    \]
\end{example}


\yx{I guess it's wise to avoid mentioning that we don't impose fixed arity.}

% \yx{mention the dilemma of simplicity and efficiency}


\section{Language, Typing and Semantics}
The syntax of Dirac notations involves three layers: the index, the type and the term.
Terms describe the concrete instances like ket, bra and operator, which will be checked and typed.
Index represents classical datatypes, and they appear in type expression to distinguish between different Hilbert spaces and sets.

\begin{definition}[index syntax]
    The syntax for type indices is
    \begin{align*}
        \sigma ::=\ & x \mid \sigma_1 \times \sigma_2 \mid \mathsf{bool}.
    \end{align*}
\end{definition}
Here $x$ is a variable. $\sigma_1 \times \sigma_2$ is the product type, which is used to represent the type of tensor product space, or Cartesian product sets.
$\mathsf{bool}$ is a constant index with two basis, and is used in Dirac notations of qubit systems.



\begin{definition}[type syntax]
    The syntax for Dirac notation types is
    \begin{align*}
        T ::=\ & \Basis(\sigma) \mid \SType \mid \KType(\sigma) \mid \BType(\sigma) \mid \OType(\sigma_1, \sigma_2) \mid T_1 \to T_2 \mid \forall x.T \mid \SET(\sigma). \\
    \end{align*}
\end{definition}
$\Basis(\sigma)$ is the type for basis in index $\sigma$. $\SType$ indicates scalars, $\KType(\sigma)$ and $\BType(\sigma)$ indicates ket and bra terms in Hilbert space $\sigma$, and $\OType(\sigma_1, \sigma_2)$ indicates linear operators with Hilbert space $\sigma_2$ as domain and $\sigma_1$ as codomain.
$\mathsf{Set}(\sigma)$ is the type of subsets in $\sigma$ index, and is used to denote the values of bound variables in summation.
The remaining two generators are types for functions. $T_1 \to T_2$ denotes normal functions, which accepts a $T_1$ type argument and results in a $T_2$ type term. $\forall x. T$ denotes index functions, which accepts an index argument $x$ and results in a $T$ type term, where $T$ can depend on $x$.

\begin{definition}[term syntax]
    The syntax for Dirac notation terms is
    \begin{align*}
        e ::=\ & x \mid \lambda x : T.e \mid \mu x.e \mid e_1\ e_2 \mid e_1 \circ e_2 \\
        & |\ \hat{0} \mid \hat{1} \mid (e_1, e_2) \\
        & |\ 0 \mid 1 \mid \ADDS(e_1, \cdots, e_n)  \mid e_1 \times \cdots \times e_n \mid e^*  \mid \delta_{e_1, e_2} \mid \DOT(e_1, e_2) \\
        & |\ \ZEROK(\sigma) \mid \ZEROB(\sigma) \mid \ZEROO(\sigma_1, \sigma_2) \mid \ONEO(\sigma) \\
        & |\ \ket{e} \mid \bra{t} \mid e^\dagger \mid e_1.e_2 \mid \ADD(e_1, \cdots, e_n) \mid e_1 \otimes e_2 \\
        & |\ \MULK(e_1, e_2) \mid \MULB(e_1, e_2) \mid \OUTER(e_1, e_2) \mid \MULO(e_1, e_2) \\
        & |\ \mathbf{U}(e) \mid e_1 \star e_2 \mid \sum_{e_1} e_2.
    \end{align*}
\end{definition}

The generators are explained in order.
$\lambda x : T.e$ is the abstraction for normal functions, and $\mu x.e$ is the abstraction for index functions.
$e_1\ e_2$ is function application. 
$e_1 \circ e_2$ is the composition operator of Dirac notations.
$\hat{0}$ and $\hat{1}$ are constant basis of $\Basis(\mathsf{bool})$ type.
$(e_1, e_2)$ is the basis pair for product types. $0$, $1$, $\ADDS$, $e_1 \times \cdots \times e_n$ and $e^*$ are symbols for scalars. 
The next line includes constant symbols for ket, bra and operator.
$e^\dagger$ denotes the conjugate transpose of $e$. $e_1.e_2$ denotes scaling the term $e_2$ with scalar $e_1$.
$\mathbf{U}(e)$ is the universal set with index $e$. $e_1 \star e_2$ is the Cartesian product. $\sum_{e_1} e_2$ is the big operator sum, which is modelled by folding the function $e_2$ over value sets $e_1$. Usually, the sum body is specified by an abstraction. Therefore we use the notation $\sum_{x \in s} X$ to denote $\sum_{s} \lambda x : T . X$ as well.
 




Here $\ADDS$ and $\ADD$ are two different AC symbols representing the scalar addition and the linear algebra addition respectively. 
% They will be denoted as $a_1 + \cdots + a_n$ and $X_1 + \cdots + X_n$.
There are five kinds of linear algebra multiplications among ket, bra and operator. We encode the typing information by using five different symbols, namely $\DOT$, $\MULK$, $\MULB$, $\OUTER$ and $\MULO$. They are denoted as $B\cdot K$, $K_1 \cdot K_2$, $B_1 \cdot B_2$, $K \cdot B$ and $O_1 \cdot O_2$, respectively.


Compared to DiracDec, our language for Dirac notations merges the symbols with identital properties, such as the addition and scaling symbols for ket, bra and operator. One important difference is that AC symbols are treated as functions with indefinite arities.



\subsection{Typing System}


The type checking of our language involves maintaining a well-formed environment and context $E[\Gamma]$, which is defined as follows.

\begin{definition}[environment and context]
    \begin{align*}
        E ::=\ & [] \mid E; x : \Index \mid E; x : T \mid E; x := t : T. \\
        \Gamma ::=\ & [] \mid \Gamma; x : \Index \mid \Gamma; x : T.
    \end{align*}
\end{definition}

The environment and the context are sequences of assumptions $x : T$ or definitions $x := t : T$.
With the environment, we can declare the type of variable symbols, and encode more operations on Dirac notations as definitions, such as the trace operator. Also, the existence of lambda abstractions requires a context of bound variables.


We say an expression $t$ has type $X$ in context $E[\Gamma]$, if the typing judgement $E[\Gamma] \vdash t : X$ can be proved through the typing rules in~\Cref{sec: full typing rules}. Here we present and explain the rules selectively. Firstly, well-formed contexts $\WF(E)[\Gamma]$ are built in the incremental way, e.g.:
\[
    \frac{}{\WF([])[]}
    \qquad
    \frac{\WF(E)[] \qquad x \notin E}{\WF(E; x : \Index)[]}
    \qquad
    \frac{E[]\vdash t:T \qquad x \notin E}{\WF(E; x:=t:T)[]}.
\]
Starting from an empty context, we can assume new index symbols, and assume or define symbols with checked types. Based on the well-formed context, typing judgements can be proved by information from $E[\Gamma]$, or built inductively. In the following rules, for example, the condition $x : \Index \in E[\Gamma]$ is true if $E$ or $\Gamma$ has the assumption in their sequences, and $\sigma \times \tau$ is a index if both $\sigma$ and $\tau$ are typed as the index. $\KType(\sigma)$ and $\OType(\sigma, \tau)$ will be valid types for kets and operators, if their arguments are typed as the index.
\begin{gather*}
    \frac{\WF(E)[\Gamma] \qquad x : \Index \in E[\Gamma]}{E[\Gamma] \vdash x : \Index}
    \qquad
    \frac{E[\Gamma] \vdash \sigma : \Index \qquad E[\Gamma] \vdash \tau : \Index}{E[\Gamma] \vdash \sigma \times \tau : \Index} \\
    \\
    \frac{E[\Gamma] \vdash \sigma : \Index}{E[\Gamma] \vdash \KType(\sigma) : \Type}
    \qquad
    \frac{E[\Gamma] \vdash \sigma : \Index \qquad E[\Gamma] \vdash \tau : \Index}{E[\Gamma] \vdash \OType(\sigma, \tau) : \Type}
\end{gather*}

The Dirac notations will then be typed accordingly. For example, the ket syntax $\ket{t}$ has type $\KType(\sigma)$, if $t$ is typed as a basis term of index $\sigma$. Also, the inner product of a bra and a ket with the same type index $\sigma$ is typed as the scalar. This corresponds to the constraint of inner products that vectors should be in the same Hilbert space.
\begin{gather*}
    \frac{E[\Gamma]\vdash t : \Basis(\sigma)}{E[\Gamma] \vdash \ket{t} : \KType(\sigma)}
    \qquad
    \frac{E[\Gamma]\vdash B : \BType(\sigma) \qquad E[\Gamma]\vdash K : \KType(\sigma)}{E[\Gamma] \vdash B \cdot K : \SType}
\end{gather*}

The typing for functions and applications follow the common practice. We specify the syntax and typing rule for functions of indices $\mu x. t$: here $x$ is a bound variable of typed as $\Index$, and the type $U\{x/u\}$ of application $(t u)$ is obtained by replacing $x$ with the index instance $u$.


\begin{gather*}
    \frac{E[\Gamma; x : T] \vdash t : U}{E[\Gamma] \vdash (\lambda x : T . t) : T \to U}
    \qquad
    \frac{E[\Gamma] \vdash t:U \to T \qquad E[\Gamma] \vdash u:U}{E[\Gamma] \vdash (t\ u):T} \\
    \\
    \frac{E[\Gamma; x : \Index] \vdash t : U}{E[\Gamma] \vdash (\mu x.t) : \forall x.U}
    \qquad
    \frac{E[\Gamma] \vdash t:\forall x.U \qquad E[\Gamma] \vdash u : \Index}{E[\Gamma] \vdash (t\ u):U\{x/u\}}
\end{gather*}


The big operator sum is modelled by folding a function on a set, therefore the typing rule is as follows:
\[
    \frac{E[\Gamma] \vdash s : \SET(\sigma) \qquad E[\Gamma] \vdash f : \Basis(\sigma) \to \KType(\tau)}{E[\Gamma] \vdash \sum_{s} f : \KType(\tau)}.
\]

And lastly we have the typing rules for composition $x \circ y$. Similar to casual Dirac notations, the typing of composition depends on the types of operands.
\begin{gather*}
    \frac{E[\Gamma] \vdash x : \SType \qquad E[\Gamma] \vdash y : \KType(\sigma)}{E[\Gamma] \vdash x \circ y : \KType(\sigma)}
    \qquad
    \frac{E[\Gamma] \vdash x : \OType(\sigma, \tau) \qquad E[\Gamma] \vdash y : \KType(\tau)}{E[\Gamma] \vdash x \circ y : \KType(\sigma)}
\end{gather*}



\begin{lemma}
    The typing of expressions are decidable and unique.
\end{lemma}

\begin{proof}
    The type can be calculated in the recursive manner. There is at most one typing rule for the same function symbol and argument types, which leads to the uniqueness of typing.
\end{proof}

\subsection{Semantics}

Semantics assign the meanings to the expressions, and the goal of the decision procedure is to decide whether
two expressions have the equivalent semantics. We consider two ways of definition: the axiomatic equations and the denotational semantics.

The denotational way interprets every expression as a linear algebra concept, and equivalence is considered in the common mathematical sense.
This explanation formalizes the original definition of Dirac notations, and best describes the target of the decision procedure.

The semantics by equations, on the other hand, is an abstraction and axiomization. From the operational view, each equation declares a 
valid rewriting operation, and two expressions are equiavlent if and only if they can be rewritten into the same form using the axioms.


\yx{where should we put the example?}
To conclude the design introduction, we demonstrate part of the formalization of the preliminary example.
\begin{example}[formalizing the preliminary example]
    Definitions and assumptions in the environment:
    \begin{align*}
        & \textrm{TPO} && := \mu T_1. \mu T_2. \lambda O : \OType(T_1, T_2). \sum_{i \in \mathbf{U}(T_1)} \sum_{j \in \mathbf{U}(T_2)} \bra{i} O \ket{j} . \ket{j}\bra{i} \\
        & && : \forall T_1. \forall T_2. \OType(T1, T2) \to \OType(T2, T1); \\
        & \textrm{phi} && := \mu T. \sum_{i \in \mathbf{U}(T)} \sum_{j \in \mathbf{U}(T)} \ket{(i, j)} : \forall T.\KType(T \times T); \\
        & \textrm{T} && : \Index; \\
        & \textrm{M} && : \OType(T, T).
    \end{align*}
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Decision procedure for Dirac notations}

The following two sections talk about how to decide the equivalence of Dirac notations.
In the previous work, the equational axioms are separated into two parts: a set $E$ of equations that can not be decided by rewriting, and the remaining equations to be decided by term rewriting.
Here, the equational theories $E$ inlude:
\begin{itemize}
    \item Commutativity of symbols $a + b$, $a\times b$ and $\delta_{s, t}$,
    \item $\alpha$-equivalence of bound variables, i.e., $\lambda x.t = \lambda y . t\{x/y\}$,
    \item swapping successive summations, i.e., $\sum_{i \in s_1} \sum_{j \in s_2} A = \sum_{j \in s_2} \sum_{i \in s_1}A$, and
    \item equational theories for scalars.
\end{itemize}

In this work, the general idea is to carry through the normalization procedure, so that semantical equivalence can be directly checked by the syntax of normal forms. The procedure of the normalization is displayed in~\Cref{fig: normalization}.

\input{flowchart.tex}

The last three steps deals with the equational theory $E$, while the first three steps use term rewriting to work on the structure of Dirac notations.


\subsection{Normalization modulo $E$ by Term Rewriting}
Term rewriting rules, written as $l -> r$, are used to normalize terms by recursively matching the subterms of the term with the left hand side $l$, and replace them with the corresponding right hand side $r$. The procedure terminates when no more rewritings can be made, and the order of rewritings will be irrelevant if the term rewriting system is \textit{confluent}, which is a desirable property.

To express the term rewriting system, the previous work adheres to use the naive universal algebra, where each function symbol has a fixed arity, and the left hand side pattern only allows constant symbols and variables. This constraint enables them to check the confluence and termination of their term rewriting system with other tools.

Here to enable more efficient algorithms, our langauge uses AC symbols with a variable arity.

The full list of rewriting rules are in~\Cref{sec: rewriting rules}. Here we present some of them to illustrate the design idea.

When using variable arity AC symbols, the associativity can be normalized by the following flattening rule:

\[
a_1 + \cdots + (b_1 + \cdots + b_m) + \cdots + a_n
\ \reduce\ a_1 + \cdots + b_1 + \cdots + b_m + \cdots + a_n,
\]

while commutativity is left for a sorting algorithm later on.

The term rewriting rule follows the system in the previous work.

The general idea is to reduce all the possible calculations, and transform multiplication into tensor product as much as possible.

And some rules exists for completeness. As an example, given the following rule snippet
\begin{align*}
    %
    & \text{(R-DOT10)}
    && (B \cdot O) \cdot K \ \reduce\ B \cdot (O \cdot K), \\
    %
    & \text{(R-DOT11)}
    && \bra{(s, t)} \cdot ((O_1 \otimes O_2) \cdot K) \ \reduce\ ((\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2)) \cdot K, \\
    %
    & \text{(R-MULB10)}
    && \bra{(s, t)} \cdot (O_1 \otimes O_2)\ \reduce\ (\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2),
\end{align*}
the normalization of term $(\bra{(s, t)} \cdot (O_1 \otimes O_2)) \cdot K$ have two rewriting paths: (a). apply (R-MULB10) and get $((\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2)) \cdot K$, or
(b). first apply (R-DOT10) and sort the term into $\bra{(s, t)} \cdot ((O_1 \otimes O_2) \cdot K)$, and then apply (R-DOT11) to get the same result. Here (R-DOT11) is for completeness of cases similar to this example.

One important technique revealed in the previous work is the expansion of variables:

\begin{gather*}
    \frac{E[\Gamma] \vdash K : \KType(\sigma)}{E[\Gamma] \vdash K \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(\bra{i}\cdot K).\ket{i}}
    \qquad \qquad
    \frac{E[\Gamma] \vdash B : \BType(\sigma)}{E[\Gamma] \vdash B \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(B \cdot \ket{i}).\bra{i}} \\
    \\
    \frac{E[\Gamma] \vdash O : \OType(\sigma, \tau)}{E[\Gamma] \vdash O \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)} \sum_{j \in \mathbf{U}(\tau)}(\bra{i} \cdot O \cdot \ket{j}).(\ket{i} \cdot \bra{j})}
\end{gather*}
The above three rules are obviously not terminating, and this is why we have the rewriting-expansion-rewriting steps in the decision procedure. On the other hand, we discovered that doing the expansion on all variables only once is already sufficient.

\begin{lemma}
    Let $\text{expand}(e)$ indicate the result of expanding all variables in $e$ once.
    For all well-typed term $e$ in $E[\Gamma]$, we have $\text{expand}(\text{expand}(e)) \downarrow = \text{expand}(e)\downarrow$.
\end{lemma}
\begin{proof}
\end{proof}



\section{Deciding Equational Theory $E$}

The previous work did not consider the algorithm to decide equational theory $E$. In their Mathematica implementation, it is implemented by a unification, which tries to find a substitution of summation bound variables that makes the two expressions syntactically equivalent. To decide AC-equivalence and (SUM-SWAP), they iterate through all the permutations, and the complexity is factorial to the number of AC symbol arguments and successive summations.

A standard approach to decide this permutation equivalence is to normalize by sorting with a given order. For example, given the dictionary order $a < b < c$, the term $b + c + a$ (and any other AC equivalent ones) will be normalized into $a + b + c$. For our setting, there are two related difficulties: how to assign such an order to all terms in our language, and how to normalize with respect to AC-equivalence and (SUM-SWAP) at the same time.

As a typical example, the two terms 
\[
    \sum_{i \in s_1} \sum_{j \in s_2} \bra{i}A\ket{j} \times \bra{j}B\ket{i}
    = 
    \sum_{i \in s_2} \sum_{j \in s_1} \bra{i}B\ket{j} \times \bra{j}A\ket{i}
\]
are equivalent due to the swap of summations and commutativity of scalar multiplication. 

We propose an algorithm to ...

To describe the algorithm, we introduce two notations: for a term $e = f(a_1, a_2, \cdots, a_n)$, $\textrm{head}(e)$ indicates the function symbol $f$,
and $\textrm{arg}(e, i)$ indicates the $i$-th argument $a_i$. Variables and constants are considered as functions with zero arguments.
\begin{definition}[order modulo bound variables]
    Assume we have a total order of all symbols.
    Let $\mathcal{B}$ be the set of bound variables.
    For simplicity, we assume all bound variables are unique. 
    The relation $e_1 < e_2$ between the two terms holds when:
    \begin{itemize}
        \item $e_1 \notin \mathcal{B}$ and $e_2 \in \mathcal{B}$, or
        \item $head(e_1) < head(e_2)$, or
        \item $head(e_1) = head(e_2)$, and there exists $n$ with $arg(e_1, n) < arg(e_2, n)$, and for all $i < n$, either $arg(e_1, i) = arg(e_2, i)$, or $arg(e_1, i) \in \mathcal{B}$ and $arg(e_2, i) \in \mathcal{B}$.
    \end{itemize}
\end{definition}

The order depends on there occurances in the last sorting result. If no occurance, then the order will depend on the set (for sum) and the type (for lambda abstraction only).

%%%%%%%%%%%%%%%%%%%%%%%


The idea is to assign an order to terms, which is independent on the bound variables. Because we can have terms with nested AC symbols.



And in the end, the $\alpha$-equivalence are checked by de Bruijn index~\cite{deBruijn1972lambda}, where references to bound variable names are replaced by the distance of the lambda abstraction to the variable. For example, the nominal lambda abstraction $\lambda x. x$ is transformed into $\lambda . 1$, while $\lambda x. \lambda y. (x\ (y\ x))$ will is transformed into $\lambda.\lambda. (2\ (1\ 2))$. Therefore, transformation into de Bruijn index is at the last step of the normalization to check the equivalence of terms with different bound variable names.


At last, we will prove that equivalence by this normalization procedure is sound in the semantics. 

\begin{theorem}[soundness]
    For any well-formed context $E[\Gamma]$ and well-typed expressions $e_1$ and $e_2$, if $e_1\downarrow = e_2\downarrow$, then $\sem{e_1} = \sem{e_2}$.
\end{theorem}
\begin{proof}
    
\end{proof}

% Labelled Dirac Notation

\input{labelled}


\section{Implementation and Case Study}

The main purpose of this work is to build a practical tool that works well in checking Dirac notation equations. The refinements and extensions above concludes in our implementation called Dirace. Dirace is a solver written in \CC\ working as a command line tool. It has a parser built by ANTLR4, and scalar reasonings are powered by a Mathematica kernel. The user can use commands to make definitions and assumptions in the maintained context, conduct the normalization and equivalence checking, and obtain the rewriting trace output. This implementation 
is tested on the benchmark of the DiracDec work, and succeeds in proving most of them efficiently.

Here is the code for the preliminary example.

    \begin{lstlisting}[style=dirace]
Var T : INDEX. Var M : OTYPE[T, T].
Def phi := idx T => Sum nv in USET[T], |(nv, nv)>.
Var r1 : REG[T]. Var r2 : REG[T].
CheckEq M_r1;r1 (phi T)_(r1, r2) with (TPO T T M)_r2;r2 (phi T)_(r1, r2).
    \end{lstlisting}        

The first three lines use the \texttt{Var} and \texttt{Def} commands to set up the context for the Dirac notation.
Here \texttt{T} is a type index, representing arbitrary Hilbert space type. \texttt{M} is assume to be an operator in Hilbert space with type \texttt{T}. \texttt{phi} is defined as the maximally entangled state.

Besides, the symbol \texttt{TPO} represents transpose of operators, and the definition is provided as
\begin{lstlisting}[style=dirace]
Def TPO := idx sigma => idx tau => fun O : OTYPE[sigma, tau] => Sum i in USET[sigma], Sum j in USET[tau], (<i| O |j>).(|j> <i|).
\end{lstlisting}


And the output result is:
    \begin{lstlisting}[style=dirace]
The two terms are equal.
[Normalized Term] SUM[USET[T], FUN[BASIS[T], SUM[USET[T], FUN[BASIS[T], SCR[DOT[BRA[$\texttt{\$1}$], MULK[M, KET[$\texttt{\$0}$]]], LTSR[LKET[$\texttt{\$1}$, r1], LKET[$\texttt{\$0}$, r2]]]]]]] : DTYPE[RSET[r1, r2], RSET]
    \end{lstlisting}

The normal form can be transformed into the formatted version:

\[
\sum_{\mathbf{U}(T)} \sum_{\mathbf{U}(T)} \bra{\$1}M\ket{\$ 0} . \ket{\$1}_{r1} \otimes \ket{\$0}_{r2} : \DType(\{r1, r2\}, \emptyset)
\]
Here $\$0$ and $\$1$ are de Bruijn indices. The result is a ket on the \{r1, r2\} system as expected.

\subsection{Benchmark performance}
It does not support fst and snd projectors.
It does not support interactive proof, as is used in the reasonings of quantum programming language theory.




\section{Related Work}

Other previous works explore the language and decision procedure to express quantum computation differently.




\section{Conclusion}
Based on the first Dirac notation equational reasoning tool DiracDec, this work refines and extends the theory for practical application, and provides the solver Dirace. Experimental results shows that the tool can correctly identify all encoded equivalent expressions efficiently. 
We expect Dirace will play a role in areas like quantum program verification or proofs of post-quantum cryptography protocols.

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TODO}
\begin{itemize}
    \item better output.
    \item better error logic
    \item the $\bar{U_{AC}}$, $\bar{U_{BC}}$ terms can be modelled by quantum registers.
\end{itemize}

\section{Things to Note}
\begin{itemize}
    \item The context should also be maintained during rewriting matching.
    \item We don't allow eta reduction. It will intertwine with SUM-SWAP and break the confluence.
    \item In each Delta reduction, the bound variables are replaced with unique variables. This should help solve the problem of conflicting variable names during substitution.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\texttt{Diracoq} language}

\begin{align*}
    cmd ::=&\ \texttt{Def}(\texttt{ID}\ term) \\
        &|\ \texttt{Def}(\texttt{ID}\ term\ type) \\
        &|\ \texttt{Var}(\texttt{ID}\ term) \\
        &|\ \texttt{Check}(term) \\
        &|\ \texttt{Show}(\texttt{ID}) \\
        &|\ \texttt{ShowAll} \\
        &|\ \texttt{Normalize}(term) \mid \texttt{Normalize}(term\ \textsf{Trace}) \\
        &|\ \texttt{CheckEq}(term\ term) \\
    type ::=&\ \texttt{Type} \mid \texttt{Arrow}(type\ type) \\
            &|\ \texttt{Base} \\
    term ::=&\ \texttt{Type} \mid \texttt{fun}(\texttt{ID}\ type\ term) \mid \texttt{apply}(term\ term) \mid \texttt{ID} \\
\end{align*}

Comment \texttt{(* ... *)} can be inserted between commands.

These are tye parsing rules for different expressions:
\begin{itemize}
    \item \texttt{Def ID := term.} --- \texttt{Def(ID term)}
    \item \texttt{Def ID := term : type.} --- \texttt{Def(ID term type)}
    \item \texttt{Var ID : type.} --- \texttt{Var(ID type)}
    \item \texttt{Check ID.} --- \texttt{Check(term)}
    \item \texttt{Show ID.} --- \texttt{Show(ID)}
    \item \texttt{ShowAll.} --- \texttt{ShowAll}
    \item \texttt{Normalize term.} --- \texttt{Normalize(term)}
    \item \texttt{Normalize term with trace.} --- \texttt{Normalize(term Trace)}
    \item \texttt{Check term = term.} --- \texttt{CheckEq(term term)}
    \item \texttt{T1 -> T2} --- \texttt{Arrow(T1 T2)}.
    \item \texttt{forall x. T} --- \texttt{Forall(x T)}
    \item \texttt{(e1, e2)} --- \texttt{PAIR(e1 e2)}
    \item \texttt{fun x : T => e} --- \texttt{fun(x T e)}
    \item \texttt{idx x => e} --- \texttt{idx(x e)}
    \item \texttt{e1 @ e2} --- \texttt{COMPO(e1 e2)}
    \item \texttt{e1 + ... + en} --- \texttt{ADDG(e1 ... en)}
    \item \texttt{e1 * ... * en} --- \texttt{STAR(e1 ... en)}
    \item \texttt{e1\^{}*} --- \texttt{CONJ(e1)}
    \item \texttt{delta(e1, e2)} --- \texttt{DELTA(e1 e2)}
    \item \texttt{|e>} --- \texttt{KET(e)}
    \item \texttt{<e|} --- \texttt{BRA(e)}
    \item \texttt{e1\^{}D} --- \texttt{ADJ(e1)}
    \item \texttt{e1.e2} --- \texttt{SCR(e1 e2)}
    \item \texttt{Sum(i in s, e)} --- \texttt{SSUM(i s e)}
\end{itemize}

These symbols will be transformed into internal language:
\begin{itemize}
    \item $A \circ B$ : $S \circ S$, $S \circ K$, $S \circ B$, $S \circ O$, $K \circ S$, $K \circ K$, $K \circ B$, $B \circ S$, $B \circ K$, $B \circ B$, $B \circ O$, $O \circ S$, $O \circ K$, $O \circ O$, $f\circ a$ (arrow), $f\circ a$ (index).
    \item \texttt{STAR(a ... b)} :  $\sigma_1 \times \sigma_2$, $\MULS(a \cdots b)$, $O_1 \otimes O_2$, $ M_1 \star M_2$
    \item \texttt{ADDG(e1 ... en)} : $\ADDS(e1 \cdots en)$, $\ADD(e1 \cdots en)$
    \item \texttt{SSUM(i S e)} : \texttt{SUM(s FUN(i T e))}
\end{itemize}

% \begin{credits}
%     \subsubsection{\ackname} A bold run-in heading in small font size at the end of the paper is
%     used for general acknowledgments, for example: This study was funded
%     by X (grant number Y).
% \end{credits}
    
    


%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{ref}
%

\appendix
\include{appendix}

\end{document}