% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}


% \usepackage[utf8]{inputenc}
% \usepackage[margin=0.8in]{geometry}




\usepackage{color}
\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{graphicx}
% \usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{multirow}
\usepackage{paralist}
\usepackage{hhline}
\usepackage{bm}
\usepackage{longtable}
\usepackage{makecell}
\usepackage{mdframed}

\usepackage{wasysym}
\usepackage{extarrows}
\usepackage{tikz}

% add new commands for comments here
\newcommand{\yx}[1]{\textit{\color{blue}[YX] : #1}}
\newcommand{\lz}[1]{\textit{\color{red}[LZ] : #1}}

\newcommand{\modify}[1]{{\color{red}#1}}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{hyperref}

\usepackage{braket}
\usepackage{cleveref}

\input{lstlisting}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}



\newenvironment{ruletable}[1]
{
    \begin{longtable}{cl}
    \caption{#1}\\
    \hline
    \textbf{Rule} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Rule} & \textbf{Description} \\
    \hline
    \endhead

    % \hline
    % \multicolumn{2}{r}{\textit{Continued on the next page}} \\
    \hline
    \endfoot

    \hline
    \endlastfoot
}
{
    \end{longtable}
}

% define C++ logo
\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}


%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
%
\begin{document}
%
\title{Dirace: Practical Proof Automation of Dirac Notation Equations}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% %\titlerunning{Abbreviated paper title}
% % If the paper title is too long for the running head, you can set
% % an abbreviated paper title here
% %
% \author{First Author\inst{1}\orcidID{0000-1111-2222-3333} \and
% Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
% Third Author\inst{3}\orcidID{2222--3333-4444-5555}}
% %
% \authorrunning{F. Author et al.}
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% %
% \institute{Princeton University, Princeton NJ 08544, USA \and
% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
% \email{lncs@springer.com}\\
% \url{http://www.springer.com/gp/computer-science/lncs} \and
% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
% \email{\{abc,lncs\}@uni-heidelberg.de}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

    Dirac notations is the fundamental language in quantum computation and quantum information reasoning. Recently, the term rewriting system DiracDec~\cite{diracdec} was introduced to automate equational reasoning with Dirac notations, a critical yet time-intensive component of formalization tasks. This work bases upon and extends DiracDec, aiming to develop a solver optimized for practical applications. Enhancements include an improved typing system, a simplified language and rewriting system, more efficient algorithms, and added support for labelled Dirac notations. The solver Dirace, implemented in \CC\ with a Mathematica backend, demonstrates superior decision-making power and computational efficiency, successfully addressing all examples in its benchmark suite.


% \keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%



%%%%%%%%%%%%%%%%
\newcommand*{\sem}[1]{{\llbracket #1 \rrbracket}}
\newcommand{\DiracDec}{\textsf{DiracDec}}

\newcommand{\reduce}{\triangleright}

\newcommand{\Sort}{\mathsf{Sort}}
\newcommand{\WF}{\mathcal{WF}}

\newcommand{\Index}{\mathsf{Index}}
\newcommand{\Type}{\mathsf{Type}}
\newcommand{\Basis}{\mathsf{Basis}}

\newcommand{\SType}{\mathcal{S}}
\newcommand{\KType}{\mathcal{K}}
\newcommand{\BType}{\mathcal{B}}
\newcommand{\OType}{\mathcal{O}}
\newcommand{\SET}{\mathsf{Set}}

\newcommand{\ZEROK}{\mathbf{0}_\mathcal{K}}
\newcommand{\ZEROB}{\mathbf{0}_\mathcal{B}}
\newcommand{\ZEROO}{\mathbf{0}_\mathcal{O}}

\newcommand{\PAIR}{\mathsf{PAIR}}

\newcommand{\ZERO}{\mathsf{0}}
\newcommand{\ONE}{\mathsf{1}}
\newcommand{\ADDS}{\mathsf{ADDS}}
\newcommand{\ADD}{\mathsf{ADD}}
\newcommand{\MULS}{\mathsf{MULS}}
\newcommand{\MUL}{\mathsf{MUL}}
\newcommand{\CONJ}{\mathsf{CONJ}}
\newcommand{\CJG}{\mathsf{CJG}}
\newcommand{\ADJ}{\mathsf{ADJ}}
\newcommand{\DELTA}{\mathsf{DELTA}}
\newcommand{\DOT}{\mathsf{DOT}}
\newcommand{\SCR}{\mathsf{SCR}}
\newcommand{\TSR}{\mathsf{TSR}}
\newcommand{\KET}{\mathsf{KET}}
\newcommand{\BRA}{\mathsf{BRA}}
\newcommand{\ONEO}{\mathbf{1}_\mathcal{O}}
\newcommand{\OUTER}{\mathsf{OUTER}}
\newcommand{\MULK}{\mathsf{MULK}}
\newcommand{\MULB}{\mathsf{MULB}}
\newcommand{\MULO}{\mathsf{MULO}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

In 1939, Dirac proposed his notation~\cite{dirac1939new} for quantum mechanics, which is designed to represent linear algebra formulae in a compact and convenient way.
For instance, $a\ket{\psi} + b\ket{\phi}$ indicates the addition of two vectors, i.e., the superposition of two states $\ket{\psi}$ and $\ket{\phi}$.
Dirac notation is now widely accepted as the working language in quantum computation and quantum information. The reasonings of Dirac notation play a fundamental role in research and application, just like boolean and integer logic to classical computer science. 
For example, formalization works of quantum algorithms and quantum programming languages involves plenty of equational proofs of Dirac notation, which are critical, repeating but time-intensive jobs.
Dirac notation are also used in quantum programming languages to define the program states, operations and assertions. In order to automate the verification procedure, we need to simplify and check the equivalence of pre-conditions. 
However, unlike the existence of SAT and SMT solver, we are still in need of a working Dirac notation solver, and this absence has become an obstacle of many areas.

Recently, Xu et al.~\cite{diracdec} proposed a theory to decide the equivalence of Dirac notations, as well as a prototype implementation in Mathematica called DiracDec.
They proved that the equivalence of basic Dirac notations are decidable.
Their algorithm sticks with a pure term rewriting system, which allows to prove important properties such as confluence and termination of the system.
Even though, there is still a gap between DiracDec and a practical solver for Dirac notation equivalence.

One problem is the algorithm efficiency for equivalence out of the scope of rewritings. DiracDec decides the whole equational theory by rewriting modulo $E$, where $E$ is a set of equational axioms that cannot be decided by normalization in rewritings, e.g. the associativity and commutativity (AC) of some function symbols. DiracDec uses a direct by inefficient algorithm to decide $E$, which search through all possible permutations and has factorial complexity.
This is witnessed in their evaluation: DiracDec is not good at dealing with "computational" examples, which has many AC symbols and are therefore time consuming.

Another problem is the lack of labelled Dirac notations.
which makes the reasoning more convenient and scaleable.

One last problem is about usability.
The typing of DiracDec only deals with Dirac notations, which is not sufficient for a working scenario, where defined symbols are desirable, and variables have their typing assumptions in the context.
Moreover, to avoid type checking during term rewriting, DiracDec uses different symbols for the same casual notation to disambiguate, which 
is not close to the natural way of using the langauge, and makes the system bloated.
It is hard to integrate the Mathematica implementation as solvers into into other tools.  
Although DiracDec solve most examples in the benchmark, including some very complicated equations, there are still a few examples that DiracDec failds to decide.



Aimming at building a practical solver, this work bases on and extends the DiracDec result, transform the term rewriting system into a hybrid algorithm, and overcomes the problems mentioned above. Our main contributions and techniques are:
\begin{itemize}
    \item An efficient algorithm to decide the extra equational theories $E$. The basic idea is normalization by sorting, which considers the interplay of AC symbols, SUM-SWAP and $\alpha$-equivalence. This algorithm reduces the complexity from the factorial level to the polynomial level.
    \item The support for constant register labels. The equivalence decision of labelled Dirac notations is then reduced into the unlabelled situation.
    \item A more usable \CC\ solver Dirace with usable language and typing. Defined symbols (e.g., transpose and trace) are modelled by functions.
\end{itemize}

As an evaluation, we tested Dirace on the benchmark of DiracDec and new example for labelled Dirac notations. Dirace successfully decides all the examples that are expressable in its language, including those failed by DiracDec because of complexity or insufficient decision power.





\section{Preliminary and Motivation}
The preliminary for the problem are two folds: Dirac notation and the equational logic in universal algebra.

Quantum states live in complex Hilbert spaces. We use vectors in the space to descirbe pure quantum states, and operations corresponds to linear transformations. 
Dirac notation are used to express the linear algebra formula in a convenient and compat way.
It uses the ket $\ket{i}$ and the bra $\bra{i}$ to indicate bases of the space and the dual space. Together with other variable symbols, they are composed with each other in sequence, and the composition will be interpreted into different operations, depending on the type of operands. For example, $\braket{i|j}$ represents the inner product of $\bra{i}$ and $\ket{j}$, which is a scalar, while $\ket{i}\bra{j}$ represents the outer product, resulting in an operator. 
Dirac notation also use $\otimes$ to indicate the vectors and operators in the tensor product space.

Dirac notation further enjoys the property that the interpretation is independent on the order of composition, thus parentheses can be omitted. For example, the formula \(\bra{i}\ket{\phi}\bra{\psi}\ket{j}\) can be understood as
\[
    \braket{i|\phi}\braket{\psi|j} = \bra{i} (\ket{\phi}\bra{\psi}) \ket{j},
\]
and they are equivalent for all variables.

With the concrete basis, Dirac notations can be interpreted as matrices. For example, the ket of two basis of qubit states are column vectors $\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}$ and $\ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}$, and the corresponding bras are row vectors in the dual space $\bra{0} = \begin{bmatrix} 1 & 0 \end{bmatrix}$ and $\bra{1} = \begin{bmatrix} 0 & 1 \end{bmatrix}$.
The calculation between Dirac notations then corresponds to matrix operatoins. For example, inner product $\braket{0| 1} = \begin{bmatrix} 0 & 1 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix} = 0$, and tensor product $\ket{0} \otimes \ket{1} = \ket{(0, 1)} = \begin{bmatrix} 1 \\ 0 \end{bmatrix} \otimes \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}$.

In practice, Dirac notations are combined with other syntax for better expressiveness. For example, the big operator sum $\sum_{i \in S} A$ are used in theoretical reasonings. We also use labelled Dirac notation, where Dirac notations are subscripted with registers to denote the quantum system in consideration, e.g. $\ket{i}_q \otimes \ket{i}_r$.

We use universal algebra and equational logic to formally represent Dirac notations and the reasoning procedure.
A universal algebra defines a signature of function symbols and the axioms. Terms in the algebra are constructed by constants, variables or function application on terms. In our case of Dirac notation, the signature consists of constructors and operations like $\ket{i}$ or $A \otimes B$, and the axioms Dirac notation equivalenc rules with equational logic.

Here is an example proof of a equivalence lemma.
\begin{example}
    Let $q$ and $r$ be two quantum systems on $\mathcal{H}_T$ space. Let $M$ be a quantum operation on $\mathcal{H}_T$,
    and $\ket{\Phi} = \sum_{i \in T} \ket{i}\otimes \ket{i}$ be the maximally entangled state, then we have
    \[
    M_q \ket{\Phi}_{q; r} = M_r^T \ket{\Phi}_{q; r}.
    \]
\end{example}


\yx{I guess it's wise to avoid mentioning that we don't impose fixed arity.}

% \yx{mention the dilemma of simplicity and efficiency}


\section{Language, Typing and Semantics}
The syntax of Dirac notations involves three layers: the index, the type and the term.
Terms describe the concrete instances like ket, bra and operator, which will be checked and typed.
Index represents classical datatypes, and they appear in type expression to distinguish between different Hilbert spaces and sets.

\begin{definition}[index syntax]
    The syntax for type indices is
    \begin{align*}
        \sigma ::=\ & x \mid \sigma_1 \times \sigma_2 \mid \mathsf{bool}.
    \end{align*}
\end{definition}
Here $x$ is a variable. $\sigma_1 \times \sigma_2$ is the product type, which is used to represent the type of tensor product space, or Cartesian product sets.
$\mathsf{bool}$ is a constant index with two basis, and is used in Dirac notations of qubit systems.



\begin{definition}[type syntax]
    The syntax for Dirac notation types is
    \begin{align*}
        T ::=\ & \Basis(\sigma) \mid \SType \mid \KType(\sigma) \mid \BType(\sigma) \mid \OType(\sigma_1, \sigma_2) \mid T_1 \to T_2 \mid \forall x.T \mid \SET(\sigma). \\
    \end{align*}
\end{definition}
$\Basis(\sigma)$ is the type for basis in index $\sigma$. $\SType$ indicates scalars, $\KType(\sigma)$ and $\BType(\sigma)$ indicates ket and bra terms in Hilbert space $\sigma$, and $\OType(\sigma_1, \sigma_2)$ indicates linear operators with Hilbert space $\sigma_2$ as domain and $\sigma_1$ as codomain.
$\mathsf{Set}(\sigma)$ is the type of subsets in $\sigma$ index, and is used to denote the values of bound variables in summation.
The remaining two generators are types for functions. $T_1 \to T_2$ denotes normal functions, which accepts a $T_1$ type argument and results in a $T_2$ type term. $\forall x. T$ denotes index functions, which accepts an index argument $x$ and results in a $T$ type term, where $T$ can depend on $x$.

\begin{definition}[term syntax]
    The syntax for Dirac notation terms is
    \begin{align*}
        e ::=\ & x \mid \lambda x : T.e \mid \mu x.e \mid e_1\ e_2 \mid e_1 \circ e_2 \\
        & |\ \hat{0} \mid \hat{1} \mid (e_1, e_2) \\
        & |\ 0 \mid 1 \mid \ADDS(e_1, \cdots, e_n)  \mid e_1 \times \cdots \times e_n \mid e^*  \mid \delta_{e_1, e_2} \mid \DOT(e_1, e_2) \\
        & |\ \ZEROK(\sigma) \mid \ZEROB(\sigma) \mid \ZEROO(\sigma_1, \sigma_2) \mid \ONEO(\sigma) \\
        & |\ \ket{e} \mid \bra{t} \mid e^\dagger \mid e_1.e_2 \mid \ADD(e_1, \cdots, e_n) \mid e_1 \otimes e_2 \\
        & |\ \MULK(e_1, e_2) \mid \MULB(e_1, e_2) \mid \OUTER(e_1, e_2) \mid \MULO(e_1, e_2) \\
        & |\ \mathbf{U}(e) \mid e_1 \star e_2 \mid \sum_{e_1} e_2.
    \end{align*}
\end{definition}

The generators are explained in order.
$\lambda x : T.e$ is the abstraction for normal functions, and $\mu x.e$ is the abstraction for index functions.
$e_1\ e_2$ is function application. 
$e_1 \circ e_2$ is the composition operator of Dirac notations.
$\hat{0}$ and $\hat{1}$ are constant basis of $\Basis(\mathsf{bool})$ type.
$(e_1, e_2)$ is the basis pair for product types. $0$, $1$, $\ADDS$, $e_1 \times \cdots \times e_n$ and $e^*$ are symbols for scalars. 
The next line includes constant symbols for ket, bra and operator.
$e^\dagger$ denotes the conjugate transpose of $e$. $e_1.e_2$ denotes scaling the term $e_2$ with scalar $e_1$.
$\mathbf{U}(e)$ is the universal set with index $e$. $e_1 \star e_2$ is the Cartesian product. $\sum_{e_1} e_2$ is the big operator sum, which is modelled by folding the function $e_2$ over value sets $e_1$. Usually, the sum body is specified by an abstraction. Therefore we use the notation $\sum_{x \in s} X$ to denote $\sum_{s} \lambda x : T . X$ as well.
 




Here $\ADDS$ and $\ADD$ are two different AC symbols representing the scalar addition and the linear algebra addition respectively. 
% They will be denoted as $a_1 + \cdots + a_n$ and $X_1 + \cdots + X_n$.
There are five kinds of linear algebra multiplications among ket, bra and operator. We encode the typing information by using five different symbols, namely $\DOT$, $\MULK$, $\MULB$, $\OUTER$ and $\MULO$. They are denoted as $B\cdot K$, $K_1 \cdot K_2$, $B_1 \cdot B_2$, $K \cdot B$ and $O_1 \cdot O_2$, respectively.


Compared to DiracDec, our language for Dirac notations merges the symbols with identital properties, such as the addition and scaling symbols for ket, bra and operator. One important difference is that AC symbols are treated as functions with indefinite arities.



\subsection{Typing System}


The type checking of our language involves maintaining a well-formed environment and context $E[\Gamma]$, which is defined as follows.

\begin{definition}[environment and context]
    \begin{align*}
        E ::=\ & [] \mid E; x : \Index \mid E; x : T \mid E; x := t : T. \\
        \Gamma ::=\ & [] \mid \Gamma; x : \Index \mid \Gamma; x : T.
    \end{align*}
\end{definition}

The environment and the context are sequences of assumptions $x : T$ or definitions $x := t : T$.
With the environment, we can declare the type of variable symbols, and encode more operations on Dirac notations as definitions, such as the trace operator. Also, the existence of lambda abstractions requires a context of bound variables.


We say an expression $t$ has type $X$ in context $E[\Gamma]$, if the typing judgement $E[\Gamma] \vdash t : X$ can be proved through the typing rules in~\Cref{sec: full typing rules}. Here we present and explain the rules selectively. Firstly, well-formed contexts $\WF(E)[\Gamma]$ are built in the incremental way, e.g.:
\[
    \frac{}{\WF([])[]}
    \qquad
    \frac{\WF(E)[] \qquad x \notin E}{\WF(E; x : \Index)[]}
    \qquad
    \frac{E[]\vdash t:T \qquad x \notin E}{\WF(E; x:=t:T)[]}.
\]
Starting from an empty context, we can assume new index symbols, and assume or define symbols with checked types. Based on the well-formed context, typing judgements can be proved by information from $E[\Gamma]$, or built inductively. In the following rules, for example, the condition $x : \Index \in E[\Gamma]$ is true if $E$ or $\Gamma$ has the assumption in their sequences, and $\sigma \times \tau$ is a index if both $\sigma$ and $\tau$ are typed as the index. $\KType(\sigma)$ and $\OType(\sigma, \tau)$ will be valid types for kets and operators, if their arguments are typed as the index.
\begin{gather*}
    \frac{\WF(E)[\Gamma] \qquad x : \Index \in E[\Gamma]}{E[\Gamma] \vdash x : \Index}
    \qquad
    \frac{E[\Gamma] \vdash \sigma : \Index \qquad E[\Gamma] \vdash \tau : \Index}{E[\Gamma] \vdash \sigma \times \tau : \Index} \\
    \\
    \frac{E[\Gamma] \vdash \sigma : \Index}{E[\Gamma] \vdash \KType(\sigma) : \Type}
    \qquad
    \frac{E[\Gamma] \vdash \sigma : \Index \qquad E[\Gamma] \vdash \tau : \Index}{E[\Gamma] \vdash \OType(\sigma, \tau) : \Type}
\end{gather*}

The Dirac notations will then be typed accordingly. For example, the ket syntax $\ket{t}$ has type $\KType(\sigma)$, if $t$ is typed as a basis term of index $\sigma$. Also, the inner product of a bra and a ket with the same type index $\sigma$ is typed as the scalar. This corresponds to the constraint of inner products that vectors should be in the same Hilbert space.
\begin{gather*}
    \frac{E[\Gamma]\vdash t : \Basis(\sigma)}{E[\Gamma] \vdash \ket{t} : \KType(\sigma)}
    \qquad
    \frac{E[\Gamma]\vdash B : \BType(\sigma) \qquad E[\Gamma]\vdash K : \KType(\sigma)}{E[\Gamma] \vdash B \cdot K : \SType}
\end{gather*}

The typing for functions and applications follow the common practice. We specify the syntax and typing rule for functions of indices $\mu x. t$: here $x$ is a bound variable of typed as $\Index$, and the type $U\{x/u\}$ of application $(t u)$ is obtained by replacing $x$ with the index instance $u$.


\begin{gather*}
    \frac{E[\Gamma; x : T] \vdash t : U}{E[\Gamma] \vdash (\lambda x : T . t) : T \to U}
    \qquad
    \frac{E[\Gamma] \vdash t:U \to T \qquad E[\Gamma] \vdash u:U}{E[\Gamma] \vdash (t\ u):T} \\
    \\
    \frac{E[\Gamma; x : \Index] \vdash t : U}{E[\Gamma] \vdash (\mu x.t) : \forall x.U}
    \qquad
    \frac{E[\Gamma] \vdash t:\forall x.U \qquad E[\Gamma] \vdash u : \Index}{E[\Gamma] \vdash (t\ u):U\{x/u\}}
\end{gather*}


The big operator sum is modelled by folding a function on a set, therefore the typing rule is as follows:
\[
    \frac{E[\Gamma] \vdash s : \SET(\sigma) \qquad E[\Gamma] \vdash f : \Basis(\sigma) \to \KType(\tau)}{E[\Gamma] \vdash \sum_{s} f : \KType(\tau)}.
\]

And lastly we have the typing rules for composition $x \circ y$. Similar to casual Dirac notations, the typing of composition depends on the types of operands.
\begin{gather*}
    \frac{E[\Gamma] \vdash x : \SType \qquad E[\Gamma] \vdash y : \KType(\sigma)}{E[\Gamma] \vdash x \circ y : \KType(\sigma)}
    \qquad
    \frac{E[\Gamma] \vdash x : \OType(\sigma, \tau) \qquad E[\Gamma] \vdash y : \KType(\tau)}{E[\Gamma] \vdash x \circ y : \KType(\sigma)}
\end{gather*}



\begin{lemma}
    The typing of expressions are decidable and unique.
\end{lemma}

\begin{proof}
    The type can be calculated in the recursive manner. There is at most one typing rule for the same function symbol and argument types, which leads to the uniqueness of typing.
\end{proof}

\subsection{Semantics}

Semantics define the meanings of expressions, and the goal of the desirable algorithm is to decide whether
two expressions have the equivalent semantics. We can give the semantics by axiomatic equations and the denotational interpretations.

\subsubsection{Denotational semantics} The denotational way interprets every expression as a set theory object in linear algebra, according to a valuation mapping $v$ from variables to their values. This explanation formalizes the common explanation of Dirac notations, and best describes the target of the algorithm.
The semantics of $e$ with valuation $v$ is written as $\sem{e}_v$, and two expressions $e_1$ and $e_2$ are equivalence if they have equal semantics in the mathematical sense for all valuations, written as $\sem{e_1} = \sem{e_2}$.

Variables typed with $\Index$ are interpreted as finite sets, and index product $\sem{\sigma_1 \times \sigma_2} = \sem{\sigma_1} \times \sem{\sigma_2}$ are defined as Cartesian product of sets. Following on, every type is interpreted as a set. For example, the scalar type $\sem{\SType} = \mathbb{C}$ is interpreted as complex number set, the the ket and bra type $\sem{\KType(\sigma)} = \mathcal{H}_{\sem{\sigma}}$, $\sem{\KType(\sigma)} = \mathcal{H}_{\sem{\sigma}}^*$ are interpreted as the Hilbert space and dual space depending on $\sigma$. One special case is the delta symbol 
$\sem{\delta_{s, t}} = 
\left \{  
    \begin{array}{ll}
        1, & \text{where } \sem{s} = \sem{t}, \\
        0, & \text{where } \sem{s} \neq \sem{t}.
    \end{array} 
\right .
$.

The idea behind the interpretation of types and terms is to characterize the typing relation with set theory inclusion. Therefore we have the following lemma.
\begin{lemma}
    For all well-formed context $E[\Gamma]$, term $t$ and type $T$, if $E[\Gamma]\vdash t : T$, then for all valuations $v$, $\sem{t}_v \in \sem{T}_v$.
\end{lemma}


\subsubsection{Axiomatic semantics} 
An other way is to express the equivalence by a set of axioms. 
% From the operational view, each equation declares a valid rewriting operation, and two expressions are equiavlent if and only if they can be rewritten into the same form using the axioms.
For example, we have the absorption law of zero symbols $X \cdot \mathbf{0} = \mathbf{0}$, and the bilinearity of dot product
\begin{align*}
    (a.X) \cdot Y = a.(X \cdot Y) \qquad X \cdot (Y_1 + Y_2) = X \cdot Y_1 + X \cdot Y_2 \\
    X \cdot (a.Y) = a.(X \cdot Y) \qquad (X_1 + X_2) \cdot Y = X_1 \cdot Y + X_2 \cdot Y
\end{align*}

Note that some equational theories cannot be decided by term rewriting, and are collected in the set $E$:

\begin{align*}
    & \textrm{AC-equivalence} 
    && \textrm{e.g.} \qquad a + b = b + a \qquad (a + b) + c = a + (b + c) \\
    & \textrm{$\alpha$-equivalence}
    && \lambda x . A = \lambda y . A\{x/y\} \\
    & \textrm{(SUM-SWAP)}
    && \sum_{i \in s_1} \sum_{j \in s_2} A = \sum_{j \in s_2} \sum_{i \in s_1} A
\end{align*}

The equations should also include axioms for scalars. In the implementation, we use the Mathematica kernel to decide scalar equivalences, so the axioms are not given here.

The equational axioms provide an operable theory for the proof automation algorithm,
and the denotational semantics can be considered as one model for the theory.
In this sense, the equivalence derived by axioms is weaker than the denotational semantics.

\begin{lemma}
    For all well-formed context $E[\Gamma]$ and terms $e_1$, $e_2$, if $AX \vdash e_1 = e_2$, then $\sem{e_1} = \sem{e_2}$.
\end{lemma}

Unfortunately, the inverse does not hold: there are expressions that are equivalent in denotational interpretations but not provable through the axioms.
One notorious example is $\delta_{i, j} \times \delta_{j, k} = \delta_{i, k} \times \delta_{j, k}$. Intuitively, the two terms will be evaluated to $1$ if and only if $i = j = k$, but it is difficult to incorporate such properties as axioms.
This incapability further limits the algorithmm, which is designed to automate reasonings using the axioms, and blocks us from proving complete results with respect to the semantics. But our work focuses on solving the practical examples, which are covered by our axioms, as is shown by experiments.


\yx{where should we put the example?}
To conclude the design introduction, we demonstrate part of the formalization of the preliminary example.
\begin{example}[formalizing the preliminary example]
    Definitions and assumptions in the environment:
    \begin{align*}
        & \textrm{TPO} && := \mu T_1. \mu T_2. \lambda O : \OType(T_1, T_2). \sum_{i \in \mathbf{U}(T_1)} \sum_{j \in \mathbf{U}(T_2)} \bra{i} O \ket{j} . \ket{j}\bra{i} \\
        & && : \forall T_1. \forall T_2. \OType(T_1, T_2) \to \OType(T_2, T_1); \\
        & \textrm{phi} && := \mu T. \sum_{i \in \mathbf{U}(T)} \sum_{j \in \mathbf{U}(T)} \ket{(i, j)} : \forall T.\KType(T \times T); \\
        & \textrm{T} && : \Index; \\
        & \textrm{M} && : \OType(T, T).
    \end{align*}
    The symbol TPO is the encoding of operator transpose. It takes two index $T_1$ and $T_2$, and transforms the operators.
    phi takes the index $T$ and defines the maximally entangled states. It sums over all basis in $T$, indicated by the universal set $\mathbf{U}(T)$.
    With the assumption of index T and operator M, we can write the equivalence as 
    \[
        (\textrm{M} \otimes \mathbf{1}_\mathcal{O}(\textrm{T})) \cdot (\textrm{phi T}) = (\mathbf{1}_\mathcal{O}(\textrm{T}) \otimes (\textrm{TPO T T M})) \cdot (\textrm{phi T}).
    \]
\end{example}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Algorithm for Deciding Dirac notations equations}

The following two sections discuss how to decide the equivalence of Dirac notations implied by the axioms.
In the previous work, the equational axioms are separated into two parts: a set $E$ of equations that can not be decided by rewriting, and the remaining equations to be decided by term rewriting.
Here, the equational theories $E$ inlude:
\begin{itemize}
    \item commutativity of symbols $a + b$, $a\times b$ and $\delta_{s, t}$,
    \item $\alpha$-equivalence of bound variables, i.e., $\lambda x.t = \lambda y . t\{x/y\}$,
    \item swapping successive summations, i.e., $\sum_{i \in s_1} \sum_{j \in s_2} A = \sum_{j \in s_2} \sum_{i \in s_1}A$, and
    \item equational theories for scalars.
\end{itemize}

In this work, the general idea is to carry through the normalization procedure, so that semantical equivalence can be directly checked by the syntax of normal forms. The procedure of the normalization is displayed in~\Cref{fig: normalization}.

\input{flowchart.tex}

The last three steps deals with the equational theory $E$, while the first three steps use term rewriting to work on the structure of Dirac notations.


\subsection{Normalization modulo $E$ by Term Rewriting}
Term rewriting rules, written as $l -> r$, are used to normalize terms by recursively matching the subterms of the term with the left hand side $l$, and replace them with the corresponding right hand side $r$. The procedure terminates when no more rewritings can be made, and the order of rewritings will be irrelevant if the term rewriting system is \textit{confluent}, which is a desirable property.

To express the term rewriting system, the previous work adheres to use the naive universal algebra, where each function symbol has a fixed arity, and the left hand side pattern only allows constant symbols and variables. This constraint enables them to check the confluence and termination of their term rewriting system with other tools.

% Here to enable more efficient algorithms, our langauge uses AC symbols with a variable arity.

The full list of rewriting rules are in~\Cref{sec: rewriting rules}. Here we present some of them to illustrate the design idea.
The whole rule list consists of several types.
Firstly, we use the following flattening rule to decide the associative with AC symbols.

\[
a_1 + \cdots + (b_1 + \cdots + b_m) + \cdots + a_n
\ \reduce\ a_1 + \cdots + b_1 + \cdots + b_m + \cdots + a_n,
\]

and commutativity is left for a sorting algorithm later on.

Some equational axioms imply obvious rewriting diraction, for example:

\begin{align*}
    &\textrm{(R-DOT6)} && \bra{s} \cdot \ket{t} \ \reduce \delta_{s, t} \\
    &\textrm{(R-DELTA0)} && \delta_{s, s} \ \reduce\ 1 \\
    &\textrm{(R-MULK1)} && O : \OType(\sigma, \tau) \Rightarrow O \cdot \mathbf{0}_{\KType(\tau)} \ \reduce \mathbf{0}_{\KType(\sigma)}
\end{align*}

The (R-DOT6) says that inner product of two basis will be evaluated to a delta expression,
and (R-DELTA0) further transforms delta on identical basis to scalar $1$.
(R-MULK1) corresponds to the axiom that multiplication on zero vectors results in zero. It has a condition on typing, which is calculated during rewriting.
They share the common feature that right hand side is simpler than the left hand side.

Other part of rules assign the rewriting diraction to equations according to the property of symbols and intuitive observations of their relations.
When different rules rewrites the same term to different forms, rules for confluence purpose are added.

\begin{align*}
    %
    & \text{(R-SCR1)} 
    && a.(b.X) \ \reduce\ (a \times b).X \\
    %
    & \text{(R-DOT10)}
    && (B \cdot O) \cdot K \ \reduce\ B \cdot (O \cdot K), \\
    %
    & \text{(R-DOT11)}
    && \bra{(s, t)} \cdot ((O_1 \otimes O_2) \cdot K) \ \reduce\ ((\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2)) \cdot K, \\
    %
    & \text{(R-MULB10)}
    && \bra{(s, t)} \cdot (O_1 \otimes O_2)\ \reduce\ (\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2),
\end{align*}
The (R-SCR1) rule follows the idea to reduce linear algebra scaling into scalar multiplications,
and (R-MULB10) transform inner product into tensor product. 
As an example of the completetion rule, here the normalization of term $(\bra{(s, t)} \cdot (O_1 \otimes O_2)) \cdot K$ have two rewriting paths: (a). apply (R-MULB10) and get $((\bra{s} \cdot O_1) \otimes (\bra{t} \cdot O_2)) \cdot K$, or
(b). first apply (R-DOT10) and sort the term into $\bra{(s, t)} \cdot ((O_1 \otimes O_2) \cdot K)$, and then apply (R-DOT11) to get the same result. Here (R-DOT11) is for completeness of cases similar to this example.

There are also rules dealing with sum expressions. For example, 

\begin{align*}
    & \textrm{(R-SUM-ELIM2)}
    && i \text{ free in } t \Rightarrow \sum_{i \in \mathbf{U}(\sigma)} \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} (\delta_{i, t}.A) \\
    & && \reduce\ \sum_{k_1 \in s_1} \cdots \sum_{k_n \in s_n} A\{i/t\} \\
    & \textrm{(R-SUM-PUSH5)}
    && (\sum_{i \in M} B)\cdot K \ \reduce\ \sum_{i \in M}(B \cdot K)
\end{align*}

The (R-SUM-ELIM2) rule will try to eliminate the delta expression in summations.
And the (R-SUM-PUSH5) rule will lift sum to the outside of inner product.



One important technique revealed in the DiracDec work is the expansion of variables:

\begin{gather*}
    \frac{E[\Gamma] \vdash K : \KType(\sigma)}{E[\Gamma] \vdash K \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(\bra{i}\cdot K).\ket{i}}
    \qquad \qquad
    \frac{E[\Gamma] \vdash B : \BType(\sigma)}{E[\Gamma] \vdash B \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)}(B \cdot \ket{i}).\bra{i}} \\
    \\
    \frac{E[\Gamma] \vdash O : \OType(\sigma, \tau)}{E[\Gamma] \vdash O \ \reduce\ \sum_{i \in \mathbf{U}(\sigma)} \sum_{j \in \mathbf{U}(\tau)}(\bra{i} \cdot O \cdot \ket{j}).(\ket{i} \cdot \bra{j})}
\end{gather*}
The above three rules are not terminating, and this is why we have the rewriting-expansion-rewriting steps in the algorithm. On the other hand, we discovered that doing the expansion on all variables only once is already sufficient.

\begin{lemma}
    Let $\text{expand}(e)$ indicate the result of expanding all variables in $e$ once.
    For all well-typed term $e$ in $E[\Gamma]$, we have $\text{expand}(\text{expand}(e)) \downarrow = \text{expand}(e)\downarrow$.
\end{lemma}
\begin{proof}
\end{proof}



\section{Deciding Equational Theory $E$}

In the Mathematica implementation of DiracDec, the equational theory $E$ is decided by a unification, which tries to find a substitution of summation bound variables and AC symbol arguments that makes the two expressions syntactically equivalent. The unification iterates through all permutations, and the complexity is factorial in general.

As the first improvement, the $\alpha$-equivalence are checked by de Bruijn index~\cite{deBruijn1972lambda}, where references to bound variable names are replaced by the distance of the lambda abstraction to the variable. For example, the nominal lambda abstraction $\lambda x. x$ is transformed into $\lambda . 1$, while $\lambda x. \lambda y. (x\ (y\ x))$ will is transformed into $\lambda.\lambda. (2\ (1\ 2))$. Therefore, transformation into de Bruijn index is at the last step of the normalization to check the equivalence of terms with different bound variable names.


A standard approach to decide this permutation equivalence is to normalize by sorting with a given order. For example, given the dictionary order $a < b < c$, the term $b + c + a$ (and any other AC equivalent ones) will be normalized into $a + b + c$. For our setting, there are two difficulties intertwined together: how to assign such an order to all terms in our language, and how to normalize with respect to $E$.
As a typical example, the two terms 
\[
    \sum_{i \in s_1} \sum_{j \in s_2} \bra{i}A\ket{j} \times \bra{j}B\ket{i}
    = 
    \sum_{i \in s_2} \sum_{j \in s_1} \bra{i}B\ket{j} \times \bra{j}A\ket{i}
\]
are equivalent due to the swap of summations and commutativity of scalar multiplication. However,
directly sorting elemnts of scalar multiplication will not lead to the same form.

We propose an algorithm to solve the problem by sorting without bound variables. The observation is that in a successive sum expression $\sum_{i \in s_1}\cdots\sum_{j \in s_n}A$, the name and order of bound variables $i, \cdots, j$ can be permuted freely. Therefore, all bound variables should be treated uniformly during sorting, and the order of sum can then be decided according to the position of their bound variables.

In the above example, we ignore the bound variables first, and sort the sum body into $\bra{\bullet}A\ket{\bullet} \times \bra{\bullet}B\ket{\bullet}$. Then we swap the sum so that the bound variable at first $\bullet$ position appears at the outside, and the two terms will have the same de Bruijn normal form as $\sum_{s_1} \sum_{s_2} \bra{\$1} A \ket{\$0} \times \bra{\$0} B \ket{\$1}$.

To describe the algorithm, we introduce two notations: for a term $e = f(a_1, a_2, \cdots, a_n)$, $\textrm{head}(e)$ indicates the function symbol $f$,
and $\textrm{arg}(e, i)$ indicates the $i$-th argument $a_i$. 
% Variables and constants are considered as functions with zero arguments.
\begin{definition}[order without bound variables]
    Assume we have a total order of all symbols.
    Let $\mathcal{B}$ be the set of bound variables.
    For simplicity, we assume all bound variables are unique.
    The relation $e_1 =_\mathcal{B} e_2$ holds when
    \begin{itemize}
        \item $head(e_1) = head(e_2)$ and $arg(e_1, i) =_\mathcal{B} arg(e_2, i)$ for all $i$, or
        \item $e_1 \in \mathcal{B}$ and $e_2 \in \mathcal{B}$.
    \end{itemize} 

    The relation $e_1 <_\mathcal{B} e_2$ between the two terms holds when:
    \begin{itemize}
        \item $e_1 \notin \mathcal{B}$ and $e_2 \in \mathcal{B}$, or
        \item $head(e_1) < head(e_2)$, or
        \item $head(e_1) = head(e_2)$, and there exists $n$ with $arg(e_1, n) <_\mathcal{B} arg(e_2, n)$, where $arg(e_1, i) =_\mathcal{B} arg(e_2, i)$ for all $i < n$.
    \end{itemize}
\end{definition}
It can be checked that $e_1 =_\mathcal{B} e_2$ if and only if neither $e_1 <_\mathcal{B} e_2$ or $e_2 <_\mathcal{B} e_1$ holds.
The idea is to compare the function symbols in the top down order, and omit bound variable occurance.


% The order depends on there occurances in the last sorting result. If no occurance, then the order will depend on the set (for sum) and the type (for lambda abstraction only).

%%%%%%%%%%%%%%%%%%%%%%%


The idea is to assign an order to terms, which is independent on the bound variables. Because we can have terms with nested AC symbols.



At last, we will prove that equivalence by this normalization procedure is sound in the semantics. 

\begin{theorem}[soundness]
    For any well-formed context $E[\Gamma]$ and well-typed expressions $e_1$ and $e_2$, if $e_1\downarrow = e_2\downarrow$, then $\sem{e_1} = \sem{e_2}$.
\end{theorem}
\begin{proof}
    
\end{proof}

% Labelled Dirac Notation

\input{labelled}


\section{Implementation and Case Study}

The main purpose of this work is to build a practical tool that works well in checking Dirac notation equations. The refinements and extensions above concludes in our implementation called Dirace. Dirace is a solver written in \CC\ working as a command line tool. It has a parser built by ANTLR4, and scalar reasonings are powered by a Mathematica kernel. The user can use commands to make definitions and assumptions in the maintained context, conduct the normalization and equivalence checking, and obtain the rewriting trace output. This implementation 
is tested on the benchmark of the DiracDec work, and succeeds in proving most of them efficiently.

Here is the code for the preliminary example.

    \begin{lstlisting}[style=dirace]
Var T : INDEX. Var M : OTYPE[T, T].
Def phi := idx T => Sum nv in USET[T], |(nv, nv)>.
Var r1 : REG[T]. Var r2 : REG[T].
CheckEq M_r1;r1 (phi T)_(r1, r2) with (TPO T T M)_r2;r2 (phi T)_(r1, r2).
    \end{lstlisting}        

The first three lines use the \texttt{Var} and \texttt{Def} commands to set up the context for the Dirac notation.
Here \texttt{T} is a type index, representing arbitrary Hilbert space type. \texttt{M} is assume to be an operator in Hilbert space with type \texttt{T}. \texttt{phi} is defined as the maximally entangled state.

Besides, the symbol \texttt{TPO} represents transpose of operators, and the definition is provided as
\begin{lstlisting}[style=dirace]
Def TPO := idx sigma => idx tau => fun O : OTYPE[sigma, tau] => Sum i in USET[sigma], Sum j in USET[tau], (<i| O |j>).(|j> <i|).
\end{lstlisting}


And the output result is:
    \begin{lstlisting}[style=dirace]
The two terms are equal.
[Normalized Term] SUM[USET[T], FUN[BASIS[T], SUM[USET[T], FUN[BASIS[T], SCR[DOT[BRA[$\texttt{\$1}$], MULK[M, KET[$\texttt{\$0}$]]], LTSR[LKET[$\texttt{\$1}$, r1], LKET[$\texttt{\$0}$, r2]]]]]]] : DTYPE[RSET[r1, r2], RSET]
    \end{lstlisting}

The normal form can be transformed into the formatted version:

\[
\sum_{\mathbf{U}(T)} \sum_{\mathbf{U}(T)} \bra{\$1}M\ket{\$ 0} . \ket{\$1}_{r1} \otimes \ket{\$0}_{r2} : \DType(\{r1, r2\}, \emptyset)
\]
Here $\$0$ and $\$1$ are de Bruijn indices. The result is a ket on the \{r1, r2\} system as expected.

\subsection{Benchmark performance}
It does not support fst and snd projectors.
It does not support interactive proof, as is used in the reasonings of quantum programming language theory.




\section{Related Work}

Other previous works exploring the language and algorithm to reasong about quantum computation differently.




\section{Conclusion}
Based on the first Dirac notation equational reasoning tool DiracDec, this work refines and extends the theory for practical application, and provides the solver Dirace. Experimental results shows that the tool can correctly identify all encoded equivalent expressions efficiently. 
We expect Dirace will play a role in areas like quantum program verification or proofs of post-quantum cryptography protocols.

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TODO}
\begin{itemize}
    \item better output.
    \item better error logic
    \item the $\bar{U_{AC}}$, $\bar{U_{BC}}$ terms can be modelled by quantum registers.
\end{itemize}

\section{Things to Note}
\begin{itemize}
    \item The context should also be maintained during rewriting matching.
    \item We don't allow eta reduction. It will intertwine with SUM-SWAP and break the confluence.
    \item In each Delta reduction, the bound variables are replaced with unique variables. This should help solve the problem of conflicting variable names during substitution.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\texttt{Diracoq} language}

\begin{align*}
    cmd ::=&\ \texttt{Def}(\texttt{ID}\ term) \\
        &|\ \texttt{Def}(\texttt{ID}\ term\ type) \\
        &|\ \texttt{Var}(\texttt{ID}\ term) \\
        &|\ \texttt{Check}(term) \\
        &|\ \texttt{Show}(\texttt{ID}) \\
        &|\ \texttt{ShowAll} \\
        &|\ \texttt{Normalize}(term) \mid \texttt{Normalize}(term\ \textsf{Trace}) \\
        &|\ \texttt{CheckEq}(term\ term) \\
    type ::=&\ \texttt{Type} \mid \texttt{Arrow}(type\ type) \\
            &|\ \texttt{Base} \\
    term ::=&\ \texttt{Type} \mid \texttt{fun}(\texttt{ID}\ type\ term) \mid \texttt{apply}(term\ term) \mid \texttt{ID} \\
\end{align*}

Comment \texttt{(* ... *)} can be inserted between commands.

These are tye parsing rules for different expressions:
\begin{itemize}
    \item \texttt{Def ID := term.} --- \texttt{Def(ID term)}
    \item \texttt{Def ID := term : type.} --- \texttt{Def(ID term type)}
    \item \texttt{Var ID : type.} --- \texttt{Var(ID type)}
    \item \texttt{Check ID.} --- \texttt{Check(term)}
    \item \texttt{Show ID.} --- \texttt{Show(ID)}
    \item \texttt{ShowAll.} --- \texttt{ShowAll}
    \item \texttt{Normalize term.} --- \texttt{Normalize(term)}
    \item \texttt{Normalize term with trace.} --- \texttt{Normalize(term Trace)}
    \item \texttt{Check term = term.} --- \texttt{CheckEq(term term)}
    \item \texttt{T1 -> T2} --- \texttt{Arrow(T1 T2)}.
    \item \texttt{forall x. T} --- \texttt{Forall(x T)}
    \item \texttt{(e1, e2)} --- \texttt{PAIR(e1 e2)}
    \item \texttt{fun x : T => e} --- \texttt{fun(x T e)}
    \item \texttt{idx x => e} --- \texttt{idx(x e)}
    \item \texttt{e1 @ e2} --- \texttt{COMPO(e1 e2)}
    \item \texttt{e1 + ... + en} --- \texttt{ADDG(e1 ... en)}
    \item \texttt{e1 * ... * en} --- \texttt{STAR(e1 ... en)}
    \item \texttt{e1\^{}*} --- \texttt{CONJ(e1)}
    \item \texttt{delta(e1, e2)} --- \texttt{DELTA(e1 e2)}
    \item \texttt{|e>} --- \texttt{KET(e)}
    \item \texttt{<e|} --- \texttt{BRA(e)}
    \item \texttt{e1\^{}D} --- \texttt{ADJ(e1)}
    \item \texttt{e1.e2} --- \texttt{SCR(e1 e2)}
    \item \texttt{Sum(i in s, e)} --- \texttt{SSUM(i s e)}
\end{itemize}

These symbols will be transformed into internal language:
\begin{itemize}
    \item $A \circ B$ : $S \circ S$, $S \circ K$, $S \circ B$, $S \circ O$, $K \circ S$, $K \circ K$, $K \circ B$, $B \circ S$, $B \circ K$, $B \circ B$, $B \circ O$, $O \circ S$, $O \circ K$, $O \circ O$, $f\circ a$ (arrow), $f\circ a$ (index).
    \item \texttt{STAR(a ... b)} :  $\sigma_1 \times \sigma_2$, $\MULS(a \cdots b)$, $O_1 \otimes O_2$, $ M_1 \star M_2$
    \item \texttt{ADDG(e1 ... en)} : $\ADDS(e1 \cdots en)$, $\ADD(e1 \cdots en)$
    \item \texttt{SSUM(i S e)} : \texttt{SUM(s FUN(i T e))}
\end{itemize}

% \begin{credits}
%     \subsubsection{\ackname} A bold run-in heading in small font size at the end of the paper is
%     used for general acknowledgments, for example: This study was funded
%     by X (grant number Y).
% \end{credits}
    
    


%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{ref}
%

\appendix
\include{appendix}

\end{document}