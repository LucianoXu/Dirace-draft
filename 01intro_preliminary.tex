
\section{Introduction}

In 1939, Dirac introduced his notation for quantum mechanics~\cite{dirac1939new}, designed to represent linear algebraic formulas in a compact and convenient form. For example, the expression \( a\ket{\psi} + b\ket{\phi} \) represents the superposition of two quantum states, \( \ket{\psi} \) and \( \ket{\phi} \). Today, Dirac notation is widely accepted as the standard language in quantum computation and quantum information. Its reasoning forms the foundation of research and applications, much like boolean and integer logic do in classical computer science.

In quantum algorithm formalizations and quantum programming languages, Dirac notation is frequently used in equational proofs, which are critical, repetitive, and often time-intensive. These notations also play a key role in defining program states, operations, and assertions in quantum programming languages. To automate the verification of these programs, we need tools that can simplify and check the equivalence of preconditions. However, unlike the well-established SAT and SMT solvers for classical logic, a practical solver for Dirac notation equivalence remains an unmet need, creating a barrier for progress in several fields.

Recently, Xu et al.~\cite{diracdec} proposed a theory for deciding the equivalence of Dirac notation, alongside a prototype implementation in Mathematica called DiracDec. They demonstrated that the equivalence of basic Dirac notation is decidable. Their algorithm, based on a pure term rewriting system, has been proven to be confluent and terminating. Despite this, there remains a gap between DiracDec and a practical solver for Dirac notation equivalence.

One challenge is the efficiency of the algorithm when dealing with equivalences beyond the scope of term rewriting. DiracDec decides the entire equational theory by rewriting modulo \( E \), where \( E \) represents a set of axioms that cannot be decided by normalization alone, such as the associativity and commutativity (AC) of certain function symbols. DiracDec uses a direct but inefficient algorithm to decide these axioms, which searches through all possible permutations and exhibits factorial complexity. This inefficiency becomes particularly evident in "computational examples" containing many AC symbols, which are time-consuming to process.

Usability is another area where DiracDec falls short. It does not support labelled Dirac notation, which uses registers to denote subsystems and express states locally. Additionally, DiracDec's typing system only does not provide context for variable typing assumptions or the definition of symbols, which are required in practical scenarios. To avoid type checking during term rewriting, DiracDec separates symbols (e.g., multiplication) for different types, leading to unnecessary complexity. Moreover, integrating the Mathematica implementation into other projects as a solver is challenging.

The system design of DiracDec reflects a trade-off between simplicity and efficiency. While the simplicity of term rewriting allows for strong theoretical results, it limits optimization opportunities. Building on DiracDec, this work aims to develop a practical solver. We transform the term rewriting system into a hybrid algorithm, overcoming the challenges mentioned above. Our main technical contributions are:
\begin{itemize}
    \item An efficient algorithm for deciding the equational theories in \( E \), based on equivalence checking through normalization, with the normal form for \( E \) being obtained via sorting.
    \item Support for constant register labels, and reducing the equivalence decision of labelled Dirac notation to the unlabelled case.
    \item A more user-friendly \CC\ solver, D-Hammer, featuring an abstract language and typing system. We also support the definition of symbols (e.g., transpose and trace) using function syntax.
\end{itemize}

We evaluated D-Hammer against the DiracDec benchmark and new examples involving labelled Dirac notation. The results show significant improvements in both decidability and efficiency compared to DiracDec.

% D-Hammer successfully decides all the examples that are expressable in its language, including those failed by DiracDec because of complexity or insufficient decision power.


\section{Motivation and Preliminary}

An interesting property of quantum mechanics is that for two maximally entangled states, applying a quantum operator \( M \) to one subsystem is equivalent to applying \( M^T \) (the transpose of \( M \)) to the other subsystem. This relationship holds regardless of the spatial separation between the two systems, and it can be expressed as an equation in Dirac notation.
\begin{example}
    \label{ex: motivating}
    Let \( q \) and \( r \) represent two quantum systems in the Hilbert space \( \mathcal{H}_T \). Let \( M \) be a quantum operation acting on \( \mathcal{H}_T \), and let \( \ket{\Phi} = \sum_{i \in T} \ket{i} \otimes \ket{i} \) be the maximally entangled state. Then, we have the following equation:
    \[
    M_q \ket{\Phi}_{q; r} = M_r^T \ket{\Phi}_{q; r}.
    \]
\end{example}

In this equation, \( q \) and \( r \) are labels denoting the respective subsystems in the Dirac notation. To automate reasoning about such equations, we must formalize the language and develop a proof system to handle it.

\subsubsection{Dirac Notation}

Quantum states are represented as vectors in complex Hilbert spaces, and operations on these states are described by linear transformations. Dirac notation uses the ket \( \ket{i} \) and the bra \( \bra{i} \) to denote basis vectors in a Hilbert space and its dual space, respectively. These symbols can be composed together in various ways to form more complex expressions. The meaning of these compositions depends on the types of the operands involved.
For example, the inner product \( \braket{i|j} \) represents the scalar result of the dot product between \( \bra{i} \) and \( \ket{j} \), while the outer product \( \ket{i}\bra{j} \) represents an operator. Additionally, Dirac notation uses the tensor product symbol \( \otimes \) to describe the combined space of multiple quantum systems.

One of the key features of Dirac notation is its order-independent interpretation. This means that the composition of terms can be written without parentheses, as the interpretation is unaffected by the order of multiplication. For instance, the formula \( \bra{i}\ket{\phi}\bra{\psi}\ket{j} \) can be understood as:
\[
    \braket{i|\phi}\braket{\psi|j} = \bra{i} (\ket{\phi}\bra{\psi}) \ket{j},
\]
and these expressions are equivalent for all variables involved.

In practice, Dirac notation is often combined with other syntactic elements, such as the summation symbol \( \sum_{i \in S} A \), to enhance expressiveness. Furthermore, labelled Dirac notation, such as \( \ket{i}_q \otimes \ket{i}_r \), is used to denote quantum systems in consideration, where subscripts (registers) are added to distinguish different subsystems.

\subsubsection{Universal Algebra}
We use universal algebra and equational logic to formally represent Dirac notation and the reasoning procedure. A universal algebra defines a signature of function symbols, with terms constructed from constants, variables, and function applications. 
Other basic concepts like substitution of variables or pattern matching are also defined.
In our case of Dirac notation, the signature consists of constructors and operations like $\ket{i}$ or $A \otimes B$.
The reasoning process is guided by equational logic, which defines an equivalence relation that is compatible with substitution and term construction. This relation formalizes the intuitive concept of equivalence in algebra.

