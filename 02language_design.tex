
\section{Dirac notation}
This section introduces the language of Dirac notation, its
denotational and axiomatic semantics, and describes D-Hammer approach
to equational reasoning. Two main ingredients of our language are:
\begin{itemize}
\item a rich typing discipline that distinguishes between scalars,
  kets, bras and operators, but supports sufficient overloading to
  remain close to standard Dirac notation;
\item higher-order, indexed (a.k.a.\, weak dependent) types. It allows
  to formally encode defined symbols like transpose or trace, which
  are usually used to represent the term in an abstract manner;
\item operators with indefinite arities. Indefinite arities are
  instrumental for reasoning efficiently about associative and
  commutative (AC) symbols have indefinite arities, as they enable
  normalization by sorting.
\end{itemize}

\subsection{Language}
Since a Hilbert space $\mathcal{H}_V$ is dependent on the basis set
$V$, types for Dirac notation also depends on the type index.
Therefore, the language is organized into three layers: the index, the
type, and the term.  Terms represent concrete instances such as kets,
bras, and operators, which will be typed and checked. The index
represents classical data types and appears in type expressions to
differentiate between various Hilbert spaces and sets.

\begin{definition}[Index Syntax]
    The syntax for type indices is:
    \begin{align*}
        \sigma ::=\ & x \mid \sigma_1 \times \sigma_2.
    \end{align*}
\end{definition}
Here, \( x \) is a variable, and \( \sigma_1 \times \sigma_2 \) represents the product type for tensor product spaces or Cartesian product sets.

\begin{definition}[Type Syntax]
    The syntax for Dirac notation types is:
    \begin{align*}
        T ::=\ & \Basis(\sigma) \mid \SType \mid \KType(\sigma) \mid \BType(\sigma) \mid \OType(\sigma_1, \sigma_2) \mid T_1 \to T_2 \mid \forall x.T \mid \SET(\sigma).
    \end{align*}
\end{definition}
\( \Basis(\sigma) \) denotes the type for basis elements in the index \( \sigma \).
\( \SType \) represents scalars, while \( \KType(\sigma) \) and \( \BType(\sigma) \) refer to ket and bra types in the Hilbert space \( \sigma \), respectively.
\( \OType(\sigma_1, \sigma_2) \) represents linear operators with \( \sigma_2 \) as the domain and \( \sigma_1 \) as the codomain.
\( \SET(\sigma) \) refers to the type of subsets of \( \sigma \), used to denote the values of bound variables in summations.
The remaining two constructs define function types: \( T_1 \to T_2 \) represents normal functions that take a \( T_1 \)-type argument and return a \( T_2 \)-type term, while \( \forall x. T \) represents index functions that take an index argument \( x \) and produce a \( T \)-type term, which may depend on \( x \).
Index functions are essential for defining polymorphic transformations across Hilbert spaces.


\begin{definition}[Term Syntax]
    The syntax for Dirac notation terms is:
    \begin{align*}
        e ::=\ & x \mid \lambda x : T.e \mid \lambda x : \Index.e \mid e_1\ e_2 \mid (e_1, e_2) \\
        & |\ 0 \mid 1 \mid e_1 \times \cdots \times e_n \mid e^* \mid \delta_{e_1, e_2} \\
        & |\ \ZEROK(\sigma) \mid \ZEROB(\sigma) \mid \ZEROO(\sigma_1, \sigma_2) \mid \ONEO(\sigma) \\
        & |\ \ket{e} \mid \bra{t} \mid e^\dagger \mid e_1.e_2 \mid e_1 + \cdots + e_n \mid e_1 \otimes e_2 \mid e_1 \cdot e_2 \\
        & |\ \mathbf{U}(\sigma) \mid e_1 \star e_2 \mid \sum_{e_1} e_2.
    \end{align*}
\end{definition}
The terms above are explained in five lines.
\begin{enumerate}
    \item \textbf{function and basis}: \( \lambda x : T.e \) represents the abstraction for normal functions, and \( \lambda x : \Index.e \) represents the abstraction for index functions.
    \( e_1\ e_2 \) denotes function application.
    \( (e_1, e_2) \) is the basis pair for product types.
    \item \textbf{scalar}: \( 0 \), \( 1 \), \( e_1 \times \cdots \times e_n \) and \( e^* \) are symbols for scalars.
    \( \delta_{e_1, e_2} \) compares where two basis are the same and evaluates to $1$ or $0$ accordingly.
    \item \textbf{Dirac constant}: zero ket, zero bra, zero operator and identity operator.
    \item \textbf{Dirac function}: \( \ket{e} \) is a ket, \( \bra{t} \) is a bra, and \( e^\dagger \) denotes the conjugate transpose of \( e \). \( e_1.e_2 \) represents scaling the term \( e_2 \) by scalar \( e_1 \). \(e_1 + \cdots + e_n\) is the addition. \( e_1 \otimes e_2 \) represents tensor product, and \( e_1 \cdot e_2 \) represents the multiplication.
    \item \textbf{summation}: \( \mathbf{U}(\sigma) \) denotes the universal set with index \( \sigma \). \( e_1 \star e_2 \) represents the Cartesian product of \( e_1 \) and \( e_2 \). \( \sum_{e_1} e_2 \) is the big operator sum, modeled by folding the function \( e_2 \) over the value set \( e_1 \). Typically, the sum's body is given by an abstraction. For convenience, we also use the notation \( \sum_{x \in s} X \) to represent \( \sum_{s} \lambda x : T . X \).
\end{enumerate}

The scalar multiplication $\times$ and addition $+$ are AC symbols, and they have indefinite arity. 
Because we use abstract syntax, the Dirac functions have different interpertations for different types. 
We use letters like $a, b, c$ to represent scalar variables, $K$ and $B$ to represent ket and bra variables, and $O$ for operators.
Therefore, $O \cdot K$ is interpreted as the operator-ket multiplication, and scalars can also be constructed from inner products $B \cdot K$.


\subsection{Typing System}
The typing system is responsible for classifying terms within a proof system, according to the types of variables and definitions. 
We use a context \( E \) to preserve the assumptions \( x : T \) and definitions \( x := t : T \).
\begin{definition}[Context]
    The syntax for context \( E \) is:
    \begin{align*}
        E ::= &\ [] \mid E; x : \Index \mid E; x : T \mid E; x := t : T.
    \end{align*}
\end{definition}
Definitions refer to symbols that can be expanded or unfolded, and typically represent abstract concepts. such as transpose or trace in Dirac notation. Assumptions, on the other hand, define the types of variables.
We say an expression \( t \) has type \( X \) in context \( E \) if the typing judgment \( E \vdash t : X \) can be proven through the rules in~\Cref{sec: full typing rules}. These are two instances:
\begin{gather*}
    \frac{E \vdash t : \Basis(\sigma)}{E \vdash \ket{t} : \KType(\sigma)},
    \qquad
    \frac{E \vdash B : \BType(\sigma) \qquad E \vdash K : \KType(\sigma)}{E \vdash B \cdot K : \SType}.
\end{gather*}
The ket \( \ket{t} \) will have the type \( \KType(\sigma) \) if \( t \) is a basis term of index \( \sigma \). Similarly, the inner product between a bra and a ket of the same index \( \sigma \) is typed as a scalar. It corresponds to the constraint of inner product that vectors should be from the same Hilbert space.
Especially, the big operator sum is modeled by folding a function over a set, with the typing rule as follows:
\[
    \frac{E \vdash s : \SET(\sigma) \qquad E \vdash f : \Basis(\sigma) \to \KType(\tau)}{E \vdash \sum_{s} f : \KType(\tau)}.
\]

% \begin{lemma}
%     The typing of expressions is both decidable and unique.
% \end{lemma}

% \begin{proof}
%     The type of an expression can be determined recursively. For any given function symbol and argument types, there is at most one typing rule, ensuring the uniqueness of typing.
% \end{proof}






\subsection{Semantics}

The semantics of a language define the meaning of its expressions. In this context, the objective of our algorithm is to determine whether two expressions are semantically equivalent. We define the semantics in a denotational manner, mapping syntax to set-theoretic objects.

\subsubsection{Denotational Semantics}
The denotational semantics interpret every expression as an object in
linear algebra, according to a valuation mapping \( v \), which
assigns values to the variables in the expression. Concretely, we
first define an interpretation $\sem{T}$ for each type.{\textcolor{red}{TODO}}


The semantics of an expression \( e \) with a given valuation \( v \)
is denoted as \( \sem{e}_v \). Two expressions \( e_1 \) and \( e_2 \)
are semantically equivalent if their semantics are equal for all
valuations, i.e., \( \sem{e_1}_v = \sem{e_2}_v \) for all \( v \).

The complete interpretation of terms and types is provided in~\Cref{sec: full denotational sem}. Variables typed with \( \Index \) are interpreted as finite sets, and the product of two indices \( \sem{\sigma_1 \times \sigma_2} \) is defined as the Cartesian product of the sets \( \sem{\sigma_1} \) and \( \sem{\sigma_2} \). More generally, each type is interpreted as a set. For example, the scalar type \( \sem{\SType} \) is interpreted as the set of complex numbers \( \mathbb{C} \), and the ket and bra types \( \sem{\KType(\sigma)} \) and \( \sem{\BType(\sigma)} \) are interpreted as the Hilbert space \( \mathcal{H}_{\sem{\sigma}} \) and its dual \( \mathcal{H}_{\sem{\sigma}}^* \), respectively. Terms are explained as the set elements. For example, the semantics of ket tensor product $\sem{K_1 \otimes K_2} \equiv \sem{K_1} \otimes \sem{K_2}$, is obtained by first calculating the semantics $\sem{K_1}$ and $\sem{K_2}$ as vectors, and then take the vector tensor product as result.

% One special case is the delta function \( \delta_{s,t} \), which is interpreted as:
% \[
%     \sem{\delta_{s,t}} =
%     \begin{cases}
%         1, & \text{if } \sem{s} = \sem{t}, \\
%         0, & \text{if } \sem{s} \neq \sem{t}.
%     \end{cases}
% \]d

The idea behind the interpretation of types and terms is to formalize the typing relation using set-theoretic inclusion. Specifically, for a well-formed context \( E \), term \( t \), and type \( T \), if \( E \vdash t : T \), then for any valuation \( v \), the semantics of \( t \) must belong to the semantics of \( T \).

\begin{lemma}
    For any well-formed context \( E \), term \( t \), and type \( T \), if \( E \vdash t : T \), then for all valuations \( v \), \( \sem{t}_v \in \sem{T}_v \).
\end{lemma}

\begin{proof}
    The proof follows directly by checking each case.
\end{proof}

This interpretation formalizes the standard understanding of Dirac notation and provides the foundation for the algorithm. However, computers cannot directly reason about equivalence through mathematical interpretations. We proceed by defining a proof system that abstracts these concepts.



\subsubsection{Axiomatic semantics} 

The proof system for equivalence is based on equational logic, together with axioms that describe the properties of Dirac notation. A full list of these axioms can be found in~\Cref{sec: full axioms}. The axioms cover fundamental aspects of linear spaces, as well as other structures like the tensor and inner products. For example, we have the absorption law for zero symbols:
\(X \cdot \mathbf{0} = \mathbf{0},\)
and the bilinearity of the dot product:
\begin{align*}
(a.X) \cdot Y = a \cdot (X \cdot Y), \quad X \cdot (Y_1 + Y_2) = X \cdot Y_1 + X \cdot Y_2, \\
X \cdot (a.Y) = a \cdot (X \cdot Y), \quad (X_1 + X_2) \cdot Y = X_1 \cdot Y + X_2 \cdot Y.
\end{align*}
The entire axioms are separated into $R$ and $F$ two sets.
During equivalence checking, most of the axioms are decided by term rewriting, which form the set $R$. However, there are axioms requiring special algorithms, which are collected in the set $F$.
\begin{definition}[axiom set F]
\label{def: axiom F}
\begin{align*}
    \text{AC-equivalence} &\quad \text{e.g.,} \quad X + Y = Y + X, \quad (X + Y) + Z = X + (Y + Z), \\
    \alpha\text{-equivalence} &\quad \lambda x . A = \lambda y . A\{x/y\}, \\
    \text{SUM-SWAP} &\quad \sum_{i \in s_1} \sum_{j \in s_2} A = \sum_{j \in s_2} \sum_{i \in s_1} A, \\
    \text{scalar theories} &\quad \text{e.g.,} \quad a + 0 = a, \quad a \times (b + c) = a \times b + a \times c.
\end{align*}
\end{definition}

The scalar theories are treated separately as a module and are not considered in this work. In the implementation, we use the Mathematica kernel to decide scalar equivalences.

These equational axioms provide an operable theory for the proof automation algorithm. Denotational semantics can be seen as one model for this theory, meaning that equivalences derived from the axioms always imply equivalence in the interpretations.
\begin{lemma}
    \label{lem: axiom sound}
    For all well-formed contexts \( E \) and terms \( e_1, e_2 \), if \( E \vdash e_1 = e_2 \), then \( \sem{e_1} = \sem{e_2} \).
\end{lemma}
\begin{proof}
    This follows directly from checking all cases.
\end{proof}

With these syntax, typing and semantics introduced, we can formalize~\Cref{eq: motivating plain}, the motivating~\Cref{ex: motivating} in plain Dirac notation.
\begin{example}[Motivating Example Formalization]
    \label{ex: formalizing motivating}
    Definitions and assumptions in the context \( E \) are formalized as follows:
    \begin{align*}
        & \text{TPO} && := \lambda T_1 : \Index. \lambda T_2 : \Index. \lambda O : \OType(T_1, T_2). \sum_{i \in \mathbf{U}(T_1)} \sum_{j \in \mathbf{U}(T_2)} \bra{i} O \ket{j} . \ket{j}\bra{i} \\
        & &&\quad : \forall T_1. \forall T_2. \OType(T_1, T_2) \to \OType(T_2, T_1); \\
        &\text{phi} &&:= \lambda T : \Index. \sum_{i \in \mathbf{U}(T)} \sum_{j \in \mathbf{U}(T)} \ket{(i, j)} : \forall T.\KType(T \times T); \\
        & T && : \Index; \\
        & M && : \OType(T, T).
    \end{align*}
    Notice how the functions and higher-order typing helps to formalize the abstract concepts here.
    The symbol \( \text{TPO} \) represents the transpose of an operator, polymorphic on the Hilbert spaces \( T_1 \) and \( T_2 \). And its type \(\forall T_1. \forall T_2. \OType(T_1, T_2) \to \OType(T_2, T_1)\) suggests that TPO is a function from operators to operators, depending on the index $T_1$ and $T_2$.
    The symbol \( \text{phi} \) takes the index \( T \) and defines the maximally entangled states, summing over all basis elements in \( T \), as indicated by the universal set \( \mathbf{U}(T) \).
    With the assumption of the index \( T \) and operator \( M \), we can express the equivalence in the plain Dirac notation as:
    \[
    (\textrm{M} \otimes \mathbf{1}_\mathcal{O}(\textrm{T})) \cdot (\textrm{phi T}) = (\mathbf{1}_\mathcal{O}(\textrm{T}) \otimes (\textrm{TPO T T M})) \cdot (\textrm{phi T}).
    \]
\end{example}



\subsection{Algorithm to Decide Equivalence}

The equivalence of Dirac notations are decided by normalization, which transforms equivalent expressions under a set of axioms into the same syntax. We use an efficient algorithm to perform the normalization totally on $R \cup F$.

\begin{enumerate}
    \item \textbf{First Rewritings}: Expand definitions and simplify expressions.
    \item \textbf{Variable Expansion}: Convert to abstract element-wise representation.
    \item \textbf{Second Rewritings}: Normalize terms on \( R \) modulo \( F \).
    \item \textbf{Sorting Without Bound Variables}: Normalize AC-equivalence.
    \item \textbf{Swap Successive Summations}: Normalize SUM-SWAP equivalence.
    \item \textbf{De Bruijn Normalization}: Normalize \( \alpha \)-equivalence.
\end{enumerate}

Here steps 1 - 3 are term rewriting for $R$. 
Term rewriting reduces a term repeatedly using a set of rules in the form of $l\ \reduce\ r$. The reduction proceeds by matching the subterms with the left-hand side, and replacing it with the right-hand side. 
For example, the rule $a.K + K\ \reduce\ (a + 1).K$ matches the term $(x\times y) . \ket{t} + \ket{t}$ by the substitution $\{a \to  x\times y, K \to \ket{t}\}$, and is rewritten into $(x\times y + 1) . \ket{t}$.
Step 1 and 3 uses the same set of rewriting rules, see~\Cref{sec: rewriting rules}.
Step 2 expands variables like the ket $K$ to their abstract element-wise representation $\sum_{i} (\bra{i} \cdot K). \ket{i}$, which improves the decidability with sum. 


Steps 4 - 6 are special algorithms to further normalize the axiom set $F$.
Here the main difficulty is the coexistence of AC-equivalence and SUM-SWAP, so that naive sorting will not convert equivalent terms to the same form.
For step 4 and 5, the key observation is that in a successive sum expression \( \sum_{i \in s_1} \cdots \sum_{j \in s_n} A \), the names and order of the bound variables \( i, \dots, j \) can be freely permuted. Therefore we first ignore bound variables and normalize AC-equivalence by sorting. Then the order of summation can be decided accordingly. The last step converts functions to de Bruijn indices~\cite{deBruijn1972lambda} to decide $\alpha$-equivalence. For detailed descriptions, see~\Cref{sec: decide}.

As a comparison, the previous work conducts normalization paritally on $R$, and decide axioms in $F$ by iterating through all possible permutations.
Our algorithm totally normalize the term, as is illustrated below.
\[
\text{(partial)}\qquad e_1 \mathop{\twoheadrightarrow}^R e_1' \mathop{=}^F e_2' \mathop{\twoheadleftarrow}^R e_2
\qquad
\text{(total)}\qquad e_1 \mathop{\twoheadrightarrow}^{R \cup F} e \equiv e \mathop{\twoheadleftarrow}^{R \cup F} e_2
\]
While the permutation checking algorithm has factorial complexity on the number of AC symbol arguments, our algorithm uses normalization by sorting, and the complexity is polynomial on the term size. This improvement in efficiency is also confirmed by experiments.


% Lastly, we can prove that the equivalence established by this normalization procedure is sound with respect to the semantics.

% \begin{theorem}[Soundness]
%     For any well-formed context \( E \) and well-typed expressions \( e_1 \) and \( e_2 \), if  $e_1$ and $e_2$ have the same normal form, then \( \sem{e_1} = \sem{e_2} \).
% \end{theorem}
% \begin{proof}
%     Because of~\Cref{lem: axiom sound}, we only need to prove soundness with respect to axioms. 
%     This is because the term rewriting procedure follows from the fact that each rewriting rule preserves equivalence. Furthermore, the operations in the sort and swap transformations respect the AC-equivalence and SUM-SWAP axioms. Finally, the de Bruijn normalization ensures soundness for \( \alpha \)-equivalence.
% \end{proof}
